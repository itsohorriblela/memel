
# 高并发系统如何设计？

1. 需求分析

高并发系统设计的第一步是对业务需求进行全面分析和理解。这包括对系统的用户数量、并发请求量、请求类型和响应时间等方面的预估和测算。同时，需要对系统的扩展性需求和预算做出明确规划。只有深入了解需求，才能为后续的架构设计提供准确的依据。

2. 架构设计

分布式架构：高并发系统通常采用分布式架构，将系统拆分为多个子系统或模块，以实现负载均衡和高可用性。常见的分布式架构包括微服务架构和分布式消息队列。

异步处理：采用异步处理方式可以将用户请求与实际业务逻辑解耦，提高系统的响应速度和并发处理能力。消息队列是实现异步处理的常见工具。

 缓存机制：合理使用缓存可以大幅度减轻数据库压力，提高系统的读取性能。常见的缓存策略包括分布式缓存和页面静态化。

 3. 负载均衡

 负载均衡是保障高并发系统稳定性和性能的关键措施。通过将请求分发到不同的服务器节点，可以避免单点故障，并确保系统的资源利用率达到最优。常见的负载均衡策略包括轮询、最小连接数和基于性能的负载均衡算法。


4. 缓存策略

缓存是高并发系统中重要的性能优化手段。适当地引入缓存可以大幅度减少数据库的访问次数，降低系统响应时间。但缓存也带来了数据一致性和过期失效等问题，需要慎重设计和管理。常见的缓存策略有全局缓存、本地缓存和分布式缓存。


5. 合理的数据库设计

在高并发系统中，数据库的设计至关重要。合理的数据库选择、数据表设计、索引优化和读写分离等措施可以显著提高数据库的性能和稳定性。此外，采用分库分表和数据库主从复制等手段也是应对高并发访问的有效方法。

6. 故障容错

高并发系统在长时间运行中难免会遇到故障，如硬件故障、网络问题或程序错误。为了保障系统的稳定性和可用性，需要实施故障容错机制，包括监控系统、自动报警、自动恢复和灾备方案等。

7. 服务降级

熔断降级是保护系统的一种手段。在分布式系统中偶尔会出现某个基础服务不可用，最终导致整个系统不可用的情况, 这种现象被称为服务雪崩效应。
保证设计的系统能应对高并发场景，那肯定要考虑熔断降级。
可降级的多级读服务：比如服务调用降级为只读本地缓存、只读分布式缓存、只读默认降级数据

8. 限流

限流的目的是防止恶意请求流量、恶意攻击，或者防止流量超出系统峰值。


# 微服务设计


微服务架构是一种软件设计模式，它将一个大型应用程序拆分成一组较小、相对独立的服务。每个服务都运行在其自己的进程中，与其他服务通信使用轻量级的通信机制（如HTTP API）。这种模式使得开发人员能够更快、更可靠地构建和维护应用程序。

## 微服务设计原则

1. 单一服务内部功能高内聚低耦合

也就是说每个服务只完成自己职责内的任务，对于不是自己职责的功能交给其它服务来完成。

2. 闭包原则

微服务的闭包原则就是当我们需要改变一个微服务的时候，所有依赖都在这个微服务的组件内，不需要修改其他微服务。

3. 服务自治，接口隔离原则

尽量消除对其他服务的强依赖，这样可以降低沟通成本，提升服务稳定性。服务通过标准的接口隔离，隐藏内部实现细节。这使得服务可以独立开发、测试、部署、运行，以服务为单位持续交付。

4. 持续演进原则

非必要情况，应逐步划分，持续演进，避免服务数量的爆炸性增长

5. 拆分的过程避免影响产品的日常迭代

也就是说要一边做产品功能迭代，一边完成服务化拆分。比如优先剥离比较独立的边界服务（如短信服务等），从非核心的服务出发减少拆分对现有业务的影响

6. 服务接口的定义要具备可扩展性

服务拆分之后，由于服务是以独立进程的方式部署，所以服务之间通信就不再是进程内部的方法调用而是跨进程的网络通信了。在这种通信模型下服务接口的定义要具备可扩展性，否则在服务变更时会造成意想不到的错误。比如微服务的接口因为升级把之前的三个参数改成了四个，上线后导致调用方大量报错，推荐做法服务接口的参数类型最好是封装类，这样如果增加参数就不必变更接口的签名，而只需要在类中添加字段就可以了

7. 避免环形依赖与双向依赖

尽量不要有服务之间的环形依赖或双向依赖，原因是存在这种情况说明我们的功能边界没有化分清楚或者有通用的功能没有下沉下来。

8. 阶段性合并

随着你对业务领域理解的逐渐深入或者业务本身逻辑发生了比较大的变化，亦或者之前的拆分没有考虑的很清楚，导致拆分后的服务边界变得越来越混乱，这时就要重新梳理领域边界，不断纠正拆分的合理性。




## 微服务设计方案

- 拆分服务：在设计微服务架构时，首先需要确定哪些功能应该被拆分成服务。这个决定应该基于不同的团队或开发者可以独立开发和维护的功能领域。

- API 设计：定义每个服务的 API 是至关重要的，因为这决定了如何与其他服务通信。API 应该是轻量级和易于使用的，最好是RESTful风格的。

- 数据管理：将数据管理作为一个服务也是很有用的。这个服务可以管理数据的存储和检索，并提供查询接口。这个服务可以被其他服务使用，以避免每个服务都要直接连接到数据库。

- 服务发现：微服务架构中的服务数量会很快增加，因此必须使用服务发现机制来管理这些服务。服务发现机制可以帮助服务找到其他服务，并根据需要建立连接。

- 负载均衡：由于服务数量的增加，负载均衡也变得很重要。负载均衡器可以根据负载情况将请求分配给多个服务实例，以提高应用程序的性能和可靠性。

- 安全性：在微服务架构中，每个服务都需要独立处理其安全性。这包括身份验证、授权和加密传输。

- 监控和日志记录：为了保持对微服务架构的控制，必须对每个服务进行监控和日志记录。这将帮助您了解服务的行为，并及时解决任何问题。
自动化部署：使用自动化部署工具可以极大地简化部署过程，并减少人为错误的可能性。


## 微服务好处

- 从开发视角来看：每个服务的功能更内聚，可以在微服务内设计和扩展功能，并且采用不同的开发语言及开发工具；

- 从运维视角来看：在微服务化后，每个服务都在独立的进程里，可以自运维；更重要的是，微服务化是单一变更的基础，迭代速度更快，上线风险更小；

- 从组织管理视角来看：将团队安装微服务切分成小组取代服务大组也有利于敏捷开发。

## 微服务缺点

- 服务数量变多，业务本身的规模和复杂度并没有变少，反而变多。

- 在分布式系统中，网络可靠性、通信安全、网络时延、网络拓扑变化等都成立我们要关注的内容。

- 微服务机制带来了大量的工作，比如服务如何请求目标服务，需要引入服务发现和负载均衡等，以及对跨进程的分布式调用栈进行分布式调用链路追踪



# lstio

Istio 是一个与Kubernetes紧密结合的适用于云原生场景的Service Mesh形态的用于服务治理的开放平台。

根据Istio官方的介绍，服务治理涉及连接（Connect）、安全（Secure）、策略执行（Control）和可观察性（Observe）。

1. 连接：Istio通过集中配置的流量规则控制服务间的流量和调用，实现负载均衡、熔断、故障注入、重试、重定向等服务治理功能。

2. 安全：Istio提供透明的认证机制、通道加密、服务访问授权等安全能力，可增强服务访问的安全性。

3. 策略执行：Istio通过可动态插拔、可扩展的策略实现访问控制、速率限制、配额管理、服务计费等能力。

4. 可观察性：动态获取服务运行数据和输出，提供强大的调用链、监控和调用日志收集输出的能力。配合可视化工具，可方便运维人员了解服务的运行状态，发现并解决问题。


## 服务网格

业界比较认同的是William Morgan关于服务网关（Service Mesh）的一段定义，这里提取和解释该定义中的几个关键字来讲解服务网格的特点：

- 基础设施：服务网格是一种处理服务间通信的基础设施层。

- 云原生：服务网格尤其适用于在云原生场景下帮助应用程序在复杂的服务拓扑间可靠地传递请求。

- 网络代理：在实际使用用，服务网格一般是通过一组轻量级网络代理来执行治理逻辑的。

- 对应用透明：轻量网络代理与应用程序部署在一起，但应用感知不到代理的存在，还是使用原来的方式工作。



在云原生时代，随着采用各种语言开发的服务剧增，应用间的访问拓扑更加复杂，治理需求也越来越多。原来的那种嵌入在应用中的治理功能无论是从形态、动态性还是可扩展性来说都不能满足需求，迫切需要一种具备云原生动态、弹性特定的应用治理基础设施。

lstio应运而生


## lstio 与 k8s

Kubernetes的Service基于每个Pod的kube-proxy从kube-apiserver上获取Service和Endpoint的信息，并将对Service的请求经过负载均衡转发到对应的Endpoint上。

但Kubernetes只提供了4层负载均衡能力，无法基于应用层的信息进行负载均衡，更不能提供应用层的流量管理，在服务运行管理上也只提供了基本的探针机制，并不能提供服务访问的指标和调用链追踪这种应用的服务运行诊断能力。

Istio复用了Kubernetes Service的定义，在实现上进行了更细粒度的控制。

Istio的服务发现就是从kube-apiserver中获取Service和Endpoint，然后将其转换成Istio服务模型的Service和ServiceInstance，但是其数据面组件不再是kube-proxy，而是在每个Pod里部署的Sidecar，也可以将其看作每个服务实例的Proxy。

通过拦截Pod的Inbound流量和Outbound流量，并在Sidecar上解析各种应用层协议，Istio可以提供真正的应用层治理、监控和安全等能力。

总之，Istio和Kubernetes从设计理念、使用体验、系统架构甚至代码风格等小细节来看，关系都非常紧密，甚至有人认为Istio就是Kubernetes团队开发的Kubernetes可插拔的增强特性。



# 库存扣减问题解决方案

1. 加锁 （悲观锁）将并发变成串行

2. 加锁（乐观锁） 扣减完成后检查

3. 消息队列

4. 重试幂等可以考虑加唯一标识token

## 基于mysql解决库存扣减的问题

1、用数据库扣减库存的方式，扣减库存的操作必须在一条语句中执行，不能先selec在update，这样在并发下会出现超扣的情况。（MySQL 默认RR隔离级别）

2、MySQL自身对于高并发的处理性能就会出现问题，一般来说，MySQL的处理性能会随着并发thread上升而上升，但是到了一定的并发度之后会出现明显的拐点，之后一路下降，最终甚至会比单thread的性能还要差。

3、当减库存和高并发碰到一起的时候，由于操作的库存数目在同一行，就会出现争抢InnoDB行锁的问题，导致出现互相等待甚至死锁，从而大大降低MySQL的处理性能，最终导致前端页面出现超时异常。

## 基于redis

### 库存放到缓存

将库存放到缓存，利用redis的incrby特性来扣减库存，解决了超扣和性能问题。但是一旦缓存丢失需要考虑恢复方案。

实现

1. 使用redis的lua脚本来实现扣减库存

2. 由于是分布式环境下所以还需要一个分布式锁来控制只能有一个服务去初始化库存

3. 需要提供一个回调函数，在初始化库存的时候去调用这个函数获取初始化库存


### 分布式锁（悲观锁）

设计一个分布式锁保证串行







