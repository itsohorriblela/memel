# 一致性哈希算法

一致性哈希算法也是使用取模的方法，但是取模算法是对服务器的数量进行取模，而一致性哈希算法是对 2^32 取模，具体步骤如下：

1. ：一致性哈希算法将整个哈希值空间按照顺时针方向组织成一个虚拟的圆环，称为 Hash 环；

2. ：接着将各个服务器使用 Hash 函数进行哈希，具体可以选择服务器的IP或主机名作为关键字进行哈希，从而确定每台机器在哈希环上的位置

3. ：最后使用算法定位数据访问到相应服务器：将数据key使用相同的函数Hash计算出哈希值，并确定此数据在环上的位置，从此位置沿环顺时针寻找，第一台遇到的服务器就是其应该定位到的服务器


一致性哈希算法在服务节点太少的情况下，容易因为节点分部不均匀而造成数据倾斜问题，也就是被缓存的对象大部分集中缓存在某一台服务器上，从而出现数据分布不均匀的情况，这种情况就称为 hash 环的倾斜。

为了解决这种数据倾斜问题，一致性哈希算法引入了虚拟节点机制，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点，一个实际物理节点可以对应多个虚拟节点，虚拟节点越多，hash环上的节点就越多，缓存被均匀分布的概率就越大，hash环倾斜所带来的影响就越小，同时数据定位算法不变，只是多了一步虚拟节点到实际节点的映射。



# json

JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。 易于人阅读和编写。同时也易于机器解析和生成。  

JSON支持两种数据结构存在： 

- object  [x, x, x]

- array    {k: v}   k必须是字符串类型  

json不支持int64 

原因： Javascript的数字存储使用了IEEE 754中规定的双精度浮点数数据类型，而这一数据类型能够安全存储 -(2^53-1) 到 2^53-1 之间的数值（包含边界值）。JSON 是 Javascript 的一个子集，所以它也遵守这个规则。




# 布隆过滤器

布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。


布隆过滤器的原理：当一个元素被加入集合时，通过 K 个散列函数将这个元素映射成一个一维数组中的 K 个点，把它们置为 1。检索时，我们只要看看这些点是不是都是 1 就（大约）知道集合中有没有它了：如果这些点有任何一个 0，则被检元素一定不在；如果都是 1，则被检元素很可能在。


# LRU算法

LRU算法的全称是“Least Recently Used”，即“最近最少使用”算法。LRU算法的基本思想是，当缓存空间已满时，优先淘汰最近最少使用的缓存数据，以腾出更多的缓存空间。因此，LRU算法需要维护一个缓存访问历史记录，以便确定哪些缓存数据是最近最少使用的。

LRU算法的实现可以采用多种数据结构，其中最常见的是使用一个双向链表和一个哈希表。双向链表用于维护缓存数据的访问顺序，哈希表用于快速查找缓存数据。具体来说，当新的数据被访问时，先在哈希表中查找该数据是否已经存在于缓存中，如果存在，则将该数据移动到双向链表的头部，表示该数据是最近访问的数据；如果不存在，则需要将该数据添加到缓存中，并将其添加到双向链表的头部。当缓存空间已满时，需要淘汰双向链表中最后一个节点，同时在哈希表中删除对应的缓存数据。


# 堆排序

要实现一个数组内的堆排序， 如果升序排序，则要用到大根堆，每次把堆顶元素放到堆最后面，堆元素数量减一。

## 如何构建一个堆呢？

大根堆： 每个节点的值均大于等于其左右孩子节点的值

构建堆最好从最后一个「非叶子节点」为根节点的子树出发，从右往左、从下往上进行调整操作。

当根结点调整后， 需要递归调整影响的子树。

## 堆如何调整

当堆顶元素变化， 需从上而下调整影响到的子树。







