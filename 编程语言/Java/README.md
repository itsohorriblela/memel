# 基础知识

## 简介

### 简单

Java 语言的语法与 C 语言和 C++ 语言很接近，使得大多数程序员很容易学习和使用。另一方面，Java 丢弃了 C++ 中很少使用的、很难理解的、令人迷惑的那些特性，如操作符重载、多继承、自动的强制类型转换。特别地，Java 语言不使用指针，而是引用。并提供了自动分配和回收内存空间，使得程序员不必为内存管理而担忧。

### 面向对象

Java 语言提供类、接口和继承等面向对象的特性，为了简单起见，只支持类之间的单继承，但支持接口之间的多继承，并支持类与接口之间的实现机制（关键字为 implements）。Java 语言全面支持动态绑定，而 C++语言只对虚函数使用动态绑定。总之，Java语言是一个纯的面向对象程序设计语言。

### 健壮

Java 的强类型机制、异常处理、垃圾的自动收集等是 Java 程序健壮性的重要保证。对指针的丢弃是 Java 的明智选择。Java 的安全检查机制使得 Java 更具健壮性。

### 体系结构中立

Java 程序（后缀为 java 的文件）在 Java 平台上被编译为体系结构中立的字节码格式（后缀为 class 的文件），然后可以在实现这个 Java 平台的任何系统中运行。这种途径适合于异构的网络环境和软件的分发。


### 解释型

如前所述，Java 程序在 Java 平台上被编译为字节码格式，然后可以在实现这个 Java 平台的任何系统中运行。在运行时，Java 平台中的 Java 解释器对这些字节码进行解释执行，执行过程中需要的类在联接阶段被载入到运行环境中。


### 高性能

与那些解释型的高级脚本语言相比，Java 的确是高性能的。事实上，Java 的运行速度随着 JIT(Just-In-Time）编译器技术的发展越来越接近于 C++。


### 多线程

在 Java 语言中，线程是一种特殊的对象，它必须由 Thread 类或其子（孙）类来创建。通常有两种方法来创建线程：其一，使用型构为 Thread(Runnable) 的构造子类将一个实现了 Runnable 接口的对象包装成一个线程，其二，从 Thread 类派生出子类并重写 run 方法，使用该子类创建的对象即为线程。值得注意的是 Thread 类已经实现了 Runnable 接口，因此，任何一个线程均有它的 run 方法，而 run 方法中包含了线程所要运行的代码。线程的活动由一组方法来控制。Java 语言支持多个线程的同时执行，并提供多线程之间的同步机制（关键字为 synchronized）。


## 基础语法概览

### 注意项
```
1. Java 是大小写敏感的  
2. 对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，采用大驼峰式。  
3. 所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。  
4. 源文件名必须和类名相同。  
5. 所有的 Java 程序由 public static void main(String[] args) 方法开始执行。  
```

### 标识符

```
1. 所有的标识符都应该以字母（A-Z 或者 a-z）,美元符（$）、或者下划线（_）开始
2. 首字符之后可以是字母（A-Z 或者 a-z）,美元符（$）、下划线（_）或数字的任何字符组合
3. 关键字不能用作标识符
4. 标识符是大小写敏感的
```

### 修饰符

像其他语言一样，Java可以使用修饰符来修饰类中方法和属性。主要有两类修饰符：
```
访问控制修饰符 : default, public , protected, private  
非访问控制修饰符 : final, abstract, static, synchronized  
```

### java变量

Java 中主要有如下几种类型的变量
```
1. 局部变量  
2. 类变量（静态变量）  
3. 成员变量（非静态变量）  
```

### java数组

数组是储存在堆上的对象，可以保存多个同类型变量。

### java枚举

Java 5.0引入了枚举，枚举限制变量只能是预先设定好的值。使用枚举可以减少代码中的 bug。

### java关键字

Java 关键字。这些保留字不能用于常量、变量、和任何标识符的名称。

### 继承

在 Java 中，一个类可以由其他类派生。如果你要创建一个类，而且已经存在一个类具有你所需要的属性或方法，那么你可以将新创建的类继承该类。
利用继承的方法，可以重用已存在类的方法和属性，而不用重写这些代码。被继承的类称为超类（super class），派生类称为子类（sub class）。

### 接口

在 Java 中，接口可理解为对象间相互通信的协议。接口在继承中扮演着很重要的角色。
接口只定义派生要用到的方法，但是方法的具体实现完全取决于派生类。


## 对象和类

### 构造方法

每个类都有构造方法。如果没有显式地为类定义构造方法，Java 编译器将会为该类提供一个默认构造方法。
在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。

### 创建对象

对象是根据类创建的。在Java中，使用关键字 new 来创建一个新的对象。创建对象需要以下三步：
1. 声明：声明一个对象，包括对象名称和对象类型。
2. 实例化：使用关键字 new 来创建一个对象。
3. 初始化：使用 new 创建对象时，会调用构造方法初始化对象。

### 源文件声明规则

```
1. 一个源文件中只能有一个 public 类  
2. 一个源文件可以有多个非 public 类  
3. 源文件的名称应该和 public 类的类名保持一致。例如：源文件中 public 类的类名是 Employee，那么源文件应该命名为Employee.java。  
4. 如果一个类定义在某个包中，那么 package 语句应该在源文件的首行。
如果源文件包含 import 语句，那么应该放在 package 语句和类定义之间。如果没有 package 语句，那么 import 语句应该在源文件中最前面。  
4. import 语句和 package 语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。  
```

### java 包

import


## 基本数据类型

### 内置数据类型

1. byte

byte 数据类型是8位、有符号的，以二进制补码表示的整数

2. short

short 数据类型是 16 位、有符号的以二进制补码表示的整数

3. int

int 数据类型是32位、有符号的以二进制补码表示的整数

4. long

long 数据类型是 64 位、有符号的以二进制补码表示的整数

5. float

float 数据类型是单精度、32位、符合IEEE 754标准的浮点数

6. double

double 数据类型是双精度、64 位、符合 IEEE 754 标准的浮点数

7. boolean

boolean数据类型表示一位的信息

8. char

char 类型是一个单一的 16 位 Unicode 字符


### 引用类型

1. 在Java中，引用类型的变量非常类似于C/C++的指针。引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型，比如 Employee、Puppy 等。变量一旦声明后，类型就不能被改变了。  
2. 对象、数组都是引用数据类型。  
3. 所有引用类型的默认值都是null。  
4. 一个引用变量可以用来引用任何与之兼容的类型。  


### 常量

常量在程序运行时是不能被修改的。
在 Java 中使用 final 关键字来修饰常量，声明方式和变量类似


### 类型转换

整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。


数据类型转换必须满足如下规则

```
1. 不能对boolean类型进行类型转换。  
2. 不能把对象类型转换成不相关类的对象。  
3. 在把容量大的类型转换为容量小的类型时必须使用强制类型转换。  
4. 转换过程中可能导致溢出或损失精度  
5. 浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入  

``` 

#### 自动类型转换

必须满足转换前的数据类型的位数要低于转换后的数据类型

#### 强制类型转换：

1. 条件是转换的数据类型必须是兼容的。
2. 格式：(type)value type是要强制类型转换后的数据类型 

#### 隐含强制类型转换

1. 整数的默认类型是 int。  
2. 小数默认是 double 类型浮点型，在定义 float 类型时必须在数字后面跟上 F 或者 f。
 

## java变量类型

在Java语言中，所有的变量在使用前必须声明。

### 参数变量

Java 中的参数变量是指在方法或构造函数中声明的变量，用于接收传递给方法或构造函数的值。参数变量与局部变量类似，但它们只在方法或构造函数被调用时存在，并且只能在方法或构造函数内部使用。

方法参数变量的值传递方式有两种：值传递和引用传递。

1. 值传递：在方法调用时，传递的是实际参数的值的副本。当参数变量被赋予新的值时，只会修改副本的值，不会影响原始值。Java 中的基本数据类型都采用值传递方式传递参数变量的值。  
2. 引用传递：在方法调用时，传递的是实际参数的引用（即内存地址）。当参数变量被赋予新的值时，会修改原始值的内容。Java 中的对象类型采用引用传递方式传递参数变量的值。
  
### 局部变量

1. 局部变量声明在方法、构造方法或者语句块中。
2. 局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁。
3. 局部变量必须在使用前声明，并且不能被访问修饰符修饰，因为它们的作用域已经被限制在了声明它们的方法、代码块或构造函数中。
4. 局部变量只在声明它的方法、构造方法或者语句块中可见，不能被其他方法或代码块访问。
5. 局部变量是在栈上分配的。
6. 局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。

### 成员变量

1. 成员变量声明在一个类中，但在方法、构造方法和语句块之外。
2. 当一个对象被实例化之后，每个成员变量的值就跟着确定。
3. 成员变量在对象创建的时候创建，在对象被销毁的时候销毁。
4. 成员变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息。
5. 成员变量可以声明在使用前或者使用后。
6. 访问修饰符可以修饰成员变量。
7. 成员变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把成员变量设为私有。通过使用访问修饰符可以使成员变量对子类可见。
8. 成员变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是 false，引用类型变量的默认值是 null。变量的值可以在声明时指定，也可以在构造方法中指定；
9. 成员变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObjectReference.VariableName。


### 静态变量

Java 中的静态变量是指在类中定义的一个变量，它与类相关而不是与实例相关，即无论创建多少个类实例，静态变量在内存中只有一份拷贝，被所有实例共享。
静态变量在类加载时被创建，在整个程序运行期间都存在。


Java 中的静态变量是属于类的，而不是对象的实例。因此，当多个线程同时访问一个包含静态变量的类时，需要考虑其线程安全性。
静态变量在内存中只有一份拷贝，被所有实例共享。因此，如果一个线程修改了静态变量的值，那么其他线程在访问该静态变量时也会看到修改后的值。这可能会导致并发访问的问题，因为多个线程可能同时修改静态变量，导致不确定的结果或数据一致性问题。
为了确保静态变量的线程安全性，需要采取适当的同步措施，如同步机制、原子类或 volatile 关键字，以便在多线程环境中正确地读取和修改静态变量的值。


## java修饰符

### 访问控制修饰符

1. default (即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。
2. private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）
3. public : 对所有类可见。使用对象：类、接口、变量、方法
4. protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。

访问控制和继承

1. 父类中声明为 public 的方法在子类中也必须为 public。  
2. 父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。  
3. 父类中声明为 private 的方法，不能够被子类继承。  

### 非访问修饰符

1. static

static 关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。 静态变量也被称为类变量。局部变量不能被声明为 static 变量。

static 关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。

2. final

final 表示"最后的、最终的"含义，变量一旦赋值后，不能被重新赋值。被 final 修饰的实例变量必须显式指定初始值。
final 修饰符通常和 static 修饰符一起使用来创建类常量。

父类中的 final 方法可以被子类继承，但是不能被子类重写。
声明 final 方法的主要目的是防止该方法的内容被修改。

final 类不能被继承，没有类能够继承 final 类的任何特性。

3. abstract

抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。

抽象方法是一种没有任何实现的方法，该方法的具体实现由子类提供。

任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。
如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。


4. synchronized

synchronized 关键字声明的方法同一时间只能被一个线程访问。

5. volatile

volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。


## java循环结构

while

do  while

for

## java条件语句

if else

switch case 执行时，一定会先进行匹配，匹配成功返回当前 case 的值，再根据是否有 break，判断是否继续输出，或是跳出判断。


## java常用的类


### Number & Math

在实际开发过程中，我们经常会遇到需要使用对象，而不是内置数据类型的情形。为了解决这个问题，Java 语言为每一个内置数据类型提供了对应的包装类。
所有的包装类（Integer、Long、Byte、Double、Float、Short）都是抽象类 Number 的子类。

Boolean  


Java 的 Math 包含了用于执行基本数学运算的属性和方法，如初等指数、对数、平方根和三角函数。
Math 的方法都被定义为 static 形式，通过 Math 类可以在主函数中直接调用。

### Character

Character 类用于对单个字符进行操作。
Character 类在对象中包装一个基本类型 char 的值

### String

字符串广泛应用 在 Java 编程中，在 Java 中字符串属于对象，Java 提供了 String 类来创建和操作字符串。


### String Buffer & String Builder

当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。
和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。

在使用 StringBuffer 类时，每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，所以如果需要对字符串进行修改推荐使用 StringBuffer。
StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。

由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。


### 数组


- 声明数组变量
```
dataType[] arrayRefVar 
```

- 创建数组

arrayRefVar = new dataType[arraySize];

- Arrays类

java.util.Arrays 类能方便地操作数组，它提供的所有方法都是静态的。



### 日期时间

java.util 包提供了 Date 类来封装当前的日期和时间。


## java 方法


java支持方法的重载

### 变量作用域

- 变量的范围是程序中该变量可以被引用的部分。  
- 方法内定义的变量被称为局部变量。
- 局部变量的作用范围从声明开始，直到包含它的块结束。
- 局部变量必须声明才可以使用。
- 方法的参数范围涵盖整个方法。参数实际上是一个局部变量。
- for循环的初始化部分声明的变量，其作用范围在整个循环。但循环体内声明的变量其适用范围是从它声明到循环体结束。

finalize方法

Java 允许定义这样的方法，它在对象被垃圾收集器析构(回收)之前调用，这个方法叫做 finalize( )，它用来清除回收对象。


## java 流Stream/文件File/IO

Java.io 包几乎包含了所有操作输入、输出需要的类。所有这些流类代表了输入源和输出目标。
Java.io 包中的流支持很多种格式，比如：基本类型、对象、本地化字符集等等。
一个流可以理解为一个数据的序列。输入流表示从一个源读取数据，输出流表示向一个目标写数据。
Java 为 I/O 提供了强大的而灵活的支持，使其更广泛地应用到文件传输和网络编程中。

System.in
System.out

FileInputStream

FileOutputStream


## java 异常处理

### Expection

所有的异常类是从 java.lang.Exception 类继承的子类。
Exception 类是 Throwable 类的子类。除了Exception类外，Throwable还有一个子类Error 。
Java 程序通常不捕获错误。错误一般发生在严重故障时，它们在Java程序处理的范畴之外。
Error 用来指示运行时环境发生的错误。

```
try
{
   // 程序代码
}catch(ExceptionName e)
{
   //Catch 块
}


```


### throw

throw 关键字用于在当前方法中抛出一个异常。


### finally

finally 关键字用来创建在 try 代码块后面执行的代码块。



# java面向对象





# java 高级教程

## 继承

继承的特性： 

1. 子类拥有父类非 private 的属性、方法。
2. 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。
3. 子类可以用自己的方式实现父类的方法。
4. Java 的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如 B 类继承 A 类，C 类继承 B 类，所以按照关系就是 B 类是 C 类的父类，A 类是 B 类的父类，这是 Java 继承区别于 C++ 继承的一个特性。
5. 提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）

extends

在 Java 中，类的继承是单一继承，也就是说，一个子类只能拥有一个父类，所以 extends 只能继承一个类。


implements

使用 implements 关键字可以变相的使java具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口（接口跟接口之间采用逗号分隔）。

super

super关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。

this

this关键字：指向自己的引用。


### 构造器

子类是不继承父类的构造器（构造方法或者构造函数）的，它只是调用（隐式或显式）。如果父类的构造器带有参数，则必须在子类的构造器中显式地通过 super 关键字调用父类的构造器并配以适当的参数列表。
如果父类构造器没有参数，则在子类的构造器中不需要使用 super 关键字调用父类构造器，系统会自动调用父类的无参构造器。

### 重写与重载

重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！


重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。


### 多态

#### 多态存在的必要条件

1. 继承

2. 重写

3. 父类引用指向子类对象


### 抽象类

在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。
抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。
由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。

### 抽象方法

如果你想设计这样一个类，该类包含一个特别的成员方法，该方法的具体实现由它的子类确定，那么你可以在父类中声明该方法为抽象方法。


### 接口

接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。

接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。
除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。

接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。


一个接口能继承另一个接口，和类之间的继承方式比较相似。接口的继承使用extends关键字，子接口继承父接口的方法。

在Java中，类的多继承是不合法，但接口允许多继承。


### 枚举

Java 枚举是一个特殊的类，一般表示一组常量，比如一年的 4 个季节，一年的 12 个月份，一个星期的 7 天，方向有东南西北等。
Java 枚举类使用 enum 关键字来定义，各个常量使用逗号 , 来分割。




# java高级教程

## 复杂数据结构

- 枚举 enum

- 位集合 bitSet

- 向量  vector

- 栈  stack

- 字典 dictionary

- 哈希表  hashTable

- 属性  properties


## java集合框架 Collection

### ArrayList

### LinkedList

### HashSet

### HashMap

### iterator 迭代器


### Object类

Java Object 类是所有类的父类，也就是说 Java 的所有类都继承了 Object，子类可以使用 Object 的所有方法。


## 泛型

Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。
泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。

## Socket编程

套接字使用TCP提供了两台计算机之间的通信机制。 客户端程序创建一个套接字，并尝试连接服务器的套接字。
当连接建立时，服务器会创建一个 Socket 对象。客户端和服务器现在可以通过对 Socket 对象的写入和读取来进行通信。
java.net.Socket 类代表一个套接字，并且 java.net.ServerSocket 类为服务器程序提供了一种来监听客户端，并与他们建立连接的机制。

## 多线程

Java 提供了三种创建线程的方法：

1. 通过实现 Runnable 接口来创建线程

2. 通过继承Thread来创建线程

3. 通过 Callable 和 Future 创建线程


有效利用多线程的关键是理解程序是并发执行而不是串行执行的。

通过对多线程的使用，可以编写出非常高效的程序。不过请注意，如果你创建太多的线程，程序执行的效率实际上是降低了，而不是提升了。

请记住，上下文的切换开销也很重要，如果你创建了太多的线程，CPU 花费在上下文的切换的时间将多于执行程序的时间！



# JAVA版本与JDK版本

## JAVA三个版本

- JAVASE （标准版）

- JAVAME （微型版）

- JAVAEE （企业版）

无论是说Java版本还是JDK版本都是针对于JavaSE这个标准版本而言，需要知道的是每个Java版本其实是对应一个具体的JDK版本，Java是一种语言，JDK是Java这门语言的开发工具包。

对应关系

```
Java 1.0 和 JDK 1.0
Java 1.1 和 JDK 1.1
J2SE 1.2 和 JDK 1.2
J2SE 1.3 和 JDK 1.3
J2SE 1.4 和 JDK 1.4
J2SE 5.0（1.5.0）和 JDK 1.5
Java SE 6 和 JDK 1.6
Java SE 7 和 JDK 1.7
Java SE 8 和 JDK 1.8
Java SE 9 和 JDK 1.9
Java SE 10 和 JDK 10
Java SE 11 和 JDK 11

```

## JDK,JRE,JVM

JDK 即Java开发工具包

JDK = JRE + java

JRE 即Java运行环境








# java 性能调优  profile

有时仅仅编写运行的代码是不够的。我们可能想知道内部发生了什么，例如内存是如何分配的，使用一种编码方法而不是另一种编码方法的后果，并发执行的影响，提高性能的领域等。我们可以为此使用探查器。

Java Profiler 是一种在 JVM 级别监视 Java 字节码构造和操作的工具。这些代码构造和操作包括对象创建、迭代执行（包括递归调用）、方法执行、线程执行和垃圾回收。


## JProfiler

JProfiler是许多开发人员的首选。通过直观的用户界面，JProfiler 提供了用于查看系统性能、内存使用情况、潜在内存泄漏和线程分析的界面。

有了这些信息，我们可以很容易地看到我们需要优化、消除或更改底层系统的内容。

该产品需要购买许可证，但也提供免费试用。


## YourKit

YourKit Java Profiler 在许多不同的平台上运行，并为每个支持的操作系统（Windows、MacOS、Linux、Solaris、FreeBSD 等）提供单独的安装。

与 JProfiler 一样，YourKit 具有可视化线程、垃圾收集、内存使用情况和内存泄漏的核心功能，并支持通过 ssh 隧道进行本地和远程分析。

YourKit 提供用于商业用途的付费许可证，其中包括免费试用版，以及用于非商业用途的低成本或免费许可证。


## CPU Profiler原理解析

使用过JProfiler的同学应该都知道，JProfiler的CPU Profiling功能提供了两种方式选项: Sampling和Instrumentation，它们也是实现CPU Profiler的两种手段。

### Sampling

Sampling方式顾名思义，基于对StackTrace的“采样”进行实现，核心原理如下：

引入Profiler依赖，或直接利用Agent技术注入目标JVM进程并启动Profiler。
启动一个采样定时器，以固定的采样频率每隔一段时间（毫秒级）对所有线程的调用栈进行Dump。
汇总并统计每次调用栈的Dump结果，在一定时间内采到足够的样本后，导出统计结果，内容是每个方法被采样到的次数及方法的调用关系。

### Instrumentation

Instrumentation则是利用Instrument API，对所有必要的Class进行字节码增强，在进入每个方法前进行埋点，方法执行结束后统计本次方法执行耗时，最终进行汇总。

### 对比

Instrumentation方式对几乎所有方法添加了额外的AOP逻辑，这会导致对线上服务造成巨额的性能影响，但其优势是：绝对精准的方法调用次数、调用时间统计。

Sampling方式基于无侵入的额外线程对所有线程的调用栈快照进行固定频率抽样，相对前者来说它的性能开销很低。但由于它基于“采样”的模式，以及JVM固有的只能在安全点（Safe Point）进行采样的“缺陷”，会导致统计结果存在一定的偏差。譬如说：某些方法执行时间极短，但执行频率很高，真实占用了大量的CPU Time，但Sampling Profiler的采样周期不能无限调小，这会导致性能开销骤增，所以会导致大量的样本调用栈中并不存在刚才提到的”高频小方法“，进而导致最终结果无法反映真实的CPU热点。


具体到“孰优孰劣”的问题层面，这两种实现技术并没有非常明显的高下之判，只有在分场景讨论下才有意义。Sampling由于低开销的特性，更适合用在CPU密集型的应用中，以及不可接受大量性能开销的线上服务中。而Instrumentation则更适合用在I/O密集的应用中、对性能开销不敏感以及确实需要精确统计的场景中。社区的Profiler更多的是基于Sampling来实现












