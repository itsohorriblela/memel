# java 性能调优  profile

有时仅仅编写运行的代码是不够的。我们可能想知道内部发生了什么，例如内存是如何分配的，使用一种编码方法而不是另一种编码方法的后果，并发执行的影响，提高性能的领域等。我们可以为此使用探查器。

Java Profiler 是一种在 JVM 级别监视 Java 字节码构造和操作的工具。这些代码构造和操作包括对象创建、迭代执行（包括递归调用）、方法执行、线程执行和垃圾回收。


## JProfiler

JProfiler是许多开发人员的首选。通过直观的用户界面，JProfiler 提供了用于查看系统性能、内存使用情况、潜在内存泄漏和线程分析的界面。

有了这些信息，我们可以很容易地看到我们需要优化、消除或更改底层系统的内容。

该产品需要购买许可证，但也提供免费试用。


## YourKit

YourKit Java Profiler 在许多不同的平台上运行，并为每个支持的操作系统（Windows、MacOS、Linux、Solaris、FreeBSD 等）提供单独的安装。

与 JProfiler 一样，YourKit 具有可视化线程、垃圾收集、内存使用情况和内存泄漏的核心功能，并支持通过 ssh 隧道进行本地和远程分析。

YourKit 提供用于商业用途的付费许可证，其中包括免费试用版，以及用于非商业用途的低成本或免费许可证。


## CPU Profiler原理解析

使用过JProfiler的同学应该都知道，JProfiler的CPU Profiling功能提供了两种方式选项: Sampling和Instrumentation，它们也是实现CPU Profiler的两种手段。

### Sampling

Sampling方式顾名思义，基于对StackTrace的“采样”进行实现，核心原理如下：

引入Profiler依赖，或直接利用Agent技术注入目标JVM进程并启动Profiler。
启动一个采样定时器，以固定的采样频率每隔一段时间（毫秒级）对所有线程的调用栈进行Dump。
汇总并统计每次调用栈的Dump结果，在一定时间内采到足够的样本后，导出统计结果，内容是每个方法被采样到的次数及方法的调用关系。

### Instrumentation

Instrumentation则是利用Instrument API，对所有必要的Class进行字节码增强，在进入每个方法前进行埋点，方法执行结束后统计本次方法执行耗时，最终进行汇总。

### 对比

Instrumentation方式对几乎所有方法添加了额外的AOP逻辑，这会导致对线上服务造成巨额的性能影响，但其优势是：绝对精准的方法调用次数、调用时间统计。

Sampling方式基于无侵入的额外线程对所有线程的调用栈快照进行固定频率抽样，相对前者来说它的性能开销很低。但由于它基于“采样”的模式，以及JVM固有的只能在安全点（Safe Point）进行采样的“缺陷”，会导致统计结果存在一定的偏差。譬如说：某些方法执行时间极短，但执行频率很高，真实占用了大量的CPU Time，但Sampling Profiler的采样周期不能无限调小，这会导致性能开销骤增，所以会导致大量的样本调用栈中并不存在刚才提到的”高频小方法“，进而导致最终结果无法反映真实的CPU热点。


具体到“孰优孰劣”的问题层面，这两种实现技术并没有非常明显的高下之判，只有在分场景讨论下才有意义。Sampling由于低开销的特性，更适合用在CPU密集型的应用中，以及不可接受大量性能开销的线上服务中。而Instrumentation则更适合用在I/O密集的应用中、对性能开销不敏感以及确实需要精确统计的场景中。社区的Profiler更多的是基于Sampling来实现












