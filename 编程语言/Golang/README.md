# GO

容易上手、编译速度快、原生支持并发、垃圾回收、代码风格清晰

Golang的相对路径是相对于执行命令时的目录


# 宏定义  
GOROOT: Go程序安装路径  
GOPATH: Go工作区，存放第三方代码  
GOBIN: Go可执行程序，引用包路径  
GOPRIVATE: 第三方私有包下载路径  


# 语言 & 框架

[语言](https://www.runoob.com/go/go-tutorial.html)  
[go-kit框架](https://gokit.io/)  
[grpc](https://grpc.io/docs/languages/go/quickstart/)  



# 优雅代码

- 统计耗时 
```
func timeCost() func() {
	start := time.Now()
	return func() {
		tc := time.Since(start)    
		fmt.Println("time cost = %v", tc)
	}
}

使用示例
defer timeCost()()   // 注意，是对 timeCost() 返回的函数进行延迟调用，因此需要加两对小括号


```

# golang浮点数计算利器 decimal 

decimal是为了解决Golang中浮点数计算时精度丢失问题而生的一个库，使用decimal库我们可以避免在go中使用浮点数出现精度丢失的问题。

github地址：https://github.com/shopspring/decimal

使用decimal的时候，切记浮点数计算所有数据的初始化必须通过decimal进行，否则还是会导致精度的丢失  

- 为什么浮点数是不精确的？ 

计算机内部数字采用二进制存储， 所以对于小数而言， 计算机只能用这些个 1/(2^n） 之和来表达十进制的小数。 而计算机不可能提供无限的空间让程序去存储这些二进制小数， 比如golang的double就是64位。



# 基础知识

## 常用方法

- defer

	defer 可以保证一些代码在函数或者方法返回之前被调用，即使方法没有正常执行完，发生了 panic，defer 后面的代码也会执行。
	在定义 defer 的时候，引用的外部参数会立刻被拷贝。

- panic

	panic 是 Go 的内置函数，可以打断当前的代码的正常执行流程，如果一个函数中出现panic，该函数后续的代码都会停止执行。但是会执行 函数 中的 defer 代码。	  
	panic 只会保证当前 goroutine 中的 defer 代码一定会执行，其他 goroutine 中的 defer 代码不保证能执行。

- recover

	recover可以从 panic 中恢复程序的正常执行。recover 需要和 defer 定义在一起。  
	recover 和 panic 需要在同一个 goroutine 使用，跨 goroutine 无法恢复应用。


## 数据结构

- context
	Go 语言中的 context.Context 的主要作用还是在多个 Goroutine 组成的树中同步取消信号以减少对资源的消耗和占用，虽然它也有传值的功能，但是这个功能我们还是很少用到。



- channel
	
	channle 本质上是一个数据结构——（队列），数据是先进先出。具有线程安全机制，多个go程访问时，不需要加锁，也就是说channel本身是线程安全的。channel是有类型的，如一个string类型的channel只能存放string类型数据。

- slice

	slice不是线程安全的

	nil切片和空切片不一样，nil切片指向的地址不存在，而所有空切片固定指向一个zero数组

- map 
	
	map不是线程安全的


- 可比较类型与不可比较类型
	
	1. 指针类型可比较，比较的是内存地址。  
    2. channel类型可比较，比较的是内存地址。  
    3. 数组类型可比较，比较的是长度、元素类型以及每个元素是否相同。  
    4. 结构体类型可比较的前提是结构体成员字段全部可以比较，并且结构体成员字段类型、个数、顺序也需要相同，当结构体成员全部相等时，两个结构体相等。  
    5. 接口类型的T和V全相等时则相等，接口类型比较时，如果底层类型不可比较，则会发生 panic。 
    6. 2 个 nil 类型可能不相等，两个nil 只有在类型相同时才相等。  
    7. slice, map, function不可比较，但可以和nil比较。至于这三种类型为什么不可比较，Golang 社区没有给出官方解释，经过分析，可能是因为 比较的维度不好衡量，难以定义一种没有争议的比较规则。   
    8. reflect.DeepEqual(value 1, value 2)可以用来比较元素是否相等。   



##  GMP

- G：gorotine（协程）

- M：machine（内核线程）

- P：processor(调度器)	


### 流程

1. 新建 G 时，新G会优先加入到 P 的本地队列；如果本地队列满了，则会把本地队列中一半的 G 移动到全局队列。

2. P 的本地队列为空时，就从全局队列里去取。

3. 如果全局队列为空时，M 会从其他 P 的本地队列偷（stealing）一半G放到自己 P 的本地队列。

4. M 运行 G，G 执行之后，M 会从 P 获取下一个 G，不断重复下去。



- M0: M0是启动程序后编号为0的主线程，当程序启动的时候会调用runtime包启动，用来执行初始化和启动第一个G。  

- G0: G0 是每次启动一个 M 都会第一个创建的 gourtine，G0 仅用于负责调度的 G，G0 不指向任何可执行的函数，每个 M 都会有一个自己的 G0（负责调度该M绑定的P的本地队列中的G）。在调度或系统调用时会使用 G0 的栈空间，全局变量的 G0 是 M0 的 G0  



## http/net

一次建立连接，就会启动一个读goroutine和写goroutine。

在获得resp.Body的内容后，不进行resp.Body.Close()，内存泄漏是一定的。


# 内存逃逸

golang程序变量会携带有一组校验数据，用来证明它的整个生命周期是否在运行时完全可知。如果变量通过了这些校验，它就可以在栈上分配。否则就说它 逃逸 了，必须在堆上分配。

能引起变量逃逸到堆上的典型情况：

- 在方法内把局部变量指针返回 

- 局部变量原本应该在栈中分配，在栈中回收。但是由于返回时被外部引用，因此其生命周期大于栈，则溢出。

- 发送指针或带有指针的值到 channel 中。 在编译时，是没有办法知道哪个 goroutine 会在 channel 上接收数据。所以编译器没法知道变量什么时候才会被释放。

- 在一个切片上存储指针或带指针的值。 尽管其后面的数组可能是在栈上分配的，但其引用的值一定是在堆上。  

- slice 的背后数组被重新分配了，因为 append 时可能会超出其容量( cap )。 slice 初始化的地方在编译时是可以知道的，它最开始会在栈上分配。如果切片背后的存储要基于运行时的数据进行扩充，就会在堆上分配。

- 在 interface 类型上调用方法。 在 interface 类型上调用方法都是动态调度的 —— 方法的真正实现只能在运行时知道。想像一个 io.Reader 类型的变量 r , 调用 r.Read(b) 会使得 r 的值和切片b 的背后存储都逃逸掉，所以会在堆上分配。


# 切片拷贝

拷贝大切片和拷贝小切片的消耗实际上一样，都是浅拷贝。（三个字段 Data Len Cap）

# 字符串转换为byte数组会发生内存拷贝吗？

字符串转成切片，会产生拷贝。严格来说，只要是发生类型强转都会发生内存拷贝。



# 垃圾回收GC

垃圾回收（Garbage Collection，简称 GC）是一种内存管理策略，由垃圾收集器以类似守护协程的方式在后台运作，按照既定的策略为用户回收那些不再被使用的对象，释放对应的内存空间.


## 几类经典的垃圾回收算法

### 标记清扫

标记清扫（Mark-Sweep）算法，分为两步走：

标记：标记出当前还存活的对象  

清扫：清扫掉未被标记到的垃圾对象  

这是一种类似于排除法的间接处理思路，不直接查找垃圾对象，而是标记存活对象，从而取补集推断出垃圾对象.  

至于标记清扫算法的不足之处，通过上图也得以窥见一二，那就是会产生内存碎片. 经过几轮标记清扫之后，空闲的内存块可能零星碎片化分布，此时倘若有大对象需要分配内存，可能会因为内存空间无法化零为整从而导致分配失败.

### 标记压缩

标记压缩（Mark-Compact）算法，是在标记清扫算法的基础上做了升级，在第二步”清扫“的同时还会对存活对象进行压缩整合，使得整体空间更为紧凑，从而解决内存碎片问题.

标记压缩算法在功能性上呈现得很出色，而其存在的缺陷也很简单，就是实现时会有很高的复杂度.


### 半空间复制

相信用过 Java 的同学对半空间复制（Semispace Copy）算法并不会感到陌生，它的核心点如下：

分配两片相等大小的空间，称为 fromspace 和 tospace

每轮只使用 fromspace 空间，以GC作为分水岭划分轮次

GC时，将fromspace存活对象转移到tospace中，并以此为契机对空间进行压缩整合

GC后，交换fromspace和tospace，开启新的轮次

显然，半空间复制算法应用了以空间换取时间的优化策略，解决了内存碎片的问题，也在一定程度上降低了压缩空间的复杂度. 但其缺点也同样很明显——比较浪费空间.


### 引用计数

引用计数（Reference Counting）算法是很简单高效的：

对象每被引用一次，计数器加1

对象每被删除引用一次，计数器减1

GC时，把计数器等于 0 的对象删除

然而，这个朴素的算法存在一个致命的缺陷：无法解决循环引用或者自引用问题.



## GOLANG的垃圾回收

### 三色标记法

Golang GC 中用到的三色标记法属于标记清扫-算法下的一种实现，由荷兰的计算机科学家 Dijkstra 提出，下面阐述要点：

- 对象分为三种颜色标记：黑、灰、白 

- 黑对象代表，对象自身存活，且其指向对象都已标记完成

- 灰对象代表，对象自身存活，但其指向对象还未标记完成

- 白对象代表，对象尙未被标记到，可能是垃圾对象

- 标记开始前，将根对象（全局对象、栈上局部变量等）置黑，将其所指向的对象置灰

- 标记规则是，从灰对象出发，将其所指向的对象都置灰. 所有指向对象都置灰后，当前灰对象置黑

- 标记结束后，白色对象就是不可达的垃圾对象，需要进行清扫.



### 并发垃圾回收

用户协程和GC协程并发操作的情况下可能会存在漏标和多标的情况


### 屏障机制

主要为了解决并发GC下的漏标问题

强三色不变式：白色对象不能被黑色对象直接引用

弱三色不变式：白色对象可以被黑色对象引用，但要从某个灰对象出发仍然可达该白对象


### 插入写屏障、删除写屏障、混合写屏障



