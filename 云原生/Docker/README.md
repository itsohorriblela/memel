# Command

- docker run: 用于在容器中运行一个新的可执行程序或命令。它是使用 Docker 镜像创建和启动容器的主要命令。  
- docker rmi: 用于删除本地的一个或多个 Docker 镜像。rmi 表示 "remove image"，即删除镜像。  
- docker build -t: 用于构建一个新的 Docker 镜像并为其指定一个标签（tag）。-t 表示 "tag"，即为镜像添加标签。  
- docker build -f: 用于指定要使用的 Dockerfile 文件路径或名称。-f 表示 "file"，即指定 Dockerfile。  
- docker --build-arg: 用于在构建 Docker 镜像时传递构建参数（build arguments）。--build-arg 选项允许您在构建过程中向 Dockerfile 中的 ARG 指令传递值。  
- docker push: 用于将本地构建的 Docker 镜像推送（上传）到远程的 Docker 镜像仓库。通过使用 docker push 命令，您可以将自己构建的镜像发布到公共或私有的镜像仓库，以供其他人访问和使用  
- docker ps: 查看正在运行的容器
- docker ps -a: 查看所有容器   
- docker pull: 下载镜像  
- docker image ls: 列出已下载的镜像  
- docker commit: 将容器保存为镜像（不建议）
- docker logs container_id:  查看日志  




# Dockerfile
- FROM：指定基础镜像，表示构建新镜像所依赖的基础操作系统镜像。  
- RUN：在镜像中执行命令。可以运行各种命令，如安装软件包、执行编译等。每个 RUN 指令都会在新的镜像层中执行，并且可以使用反斜杠（\）进行多行命令的拆分。  
- COPY：将文件从构建上下文复制到镜像中。COPY 指令可以复制本地文件到镜像中的指定路径。源文件可以是文件或目录。
- WORKDIR：设置工作目录，即后续指令执行的默认路径。  
- ENV：设置环境变量。可以在后续的指令中使用这些环境变量。
- EXPOSE：声明容器运行时监听的端口号。这只是一个元数据，用于指示容器在运行时可以接受的网络连接。  
- CMD：指定容器启动时要执行的命令。CMD 可以提供默认值，但可以被 Dockerfile 中的其他 CMD 或 ENTRYPOINT 覆盖。在 Dockerfile 中，可以使用多个 CMD 指令，但只有最后一个 CMD 指令会生效。如果在 Dockerfile 中出现多个 CMD 指令，那么只有最后一个 CMD 指令会被执行，之前的 CMD 指令将被忽略。  
- ENTRYPOINT：指定容器启动时要执行的固定命令。ENTRYPOINT 的参数是不可覆盖的，但可以与 CMD 结合使用。
- VOLUME：声明容器中的挂载点，用于持久化存储数据。这使得可以将主机文件系统的目录或其他容器的挂载点与容器内的特定目录进行关联。  
- WORKDIR 是 Dockerfile 中的指令，用于设置工作目录（Working Directory）。它指定了后续指令执行的默认路径。WORKDIR 指令并不会创建实际的目录结构，只是在 Dockerfile 中设置一个工作目录的上下文。如果工作目录不存在，Docker 在执行后续指令时会自动创建该目录  


# 基础知识 

Docker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 OverlayFS 类的 Union FS 等技术，对进程进行封装隔离，属于 操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。最初实现是基于 LXC，从 0.7 版本以后开始去除 LXC，转而使用自行开发的 libcontainer，从 1.11 版本开始，则进一步演进为使用 runC 和 containerd。   


传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。  


## 镜像  
	
	Docker 镜像 是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像 不包含 任何动态数据，其内容在构建之后也不会被改变。   

### 基础镜像：  
	
	不依赖其他镜像  
	其他镜像可基于基础镜像做扩展  
	基础镜像中的操作系统是不完整的，缺少内核，需要使用宿主机上的操作系统的内核。  
	

## 容器  

	容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。  
	每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为 容器存储层。  
	容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。  
 
## 仓库  

	一个 Docker Registry 中可以包含多个 仓库（Repository）；每个仓库可以包含多个 标签（Tag）；每个标签对应一个镜像。  
	通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 <仓库名>:<标签> 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。  


# 数据管理

容器中管理数据主要有两种方式：数据卷   挂载主机目录  

## 数据卷  

数据卷 是被设计用来持久化数据的，它的生命周期独立于容器，Docker 不会在容器被删除后自动删除 数据卷，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的 数据卷。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 docker rm -v 这个命令。    

## 挂载主机目录  

使用 --mount 标记可以指定挂载一个本地主机的目录到容器中去。  

# 使用网络  

-p 指定容器对外映射的端口


# 守护进程  

Docker Daemon（守护进程）是Docker的核心组件之一，它是在主机上运行的后台进程，负责管理和控制Docker容器的创建、运行和管理。










