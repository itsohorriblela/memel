# Redis优点

1. 读写性能优异  
2. 数据类型丰富  
3. Redis的所有操作都是原子性的，同时Redis还支持对几个操作一起的原子性执行  
4. 丰富的特性，支持发布订阅，key过期  
5. 分布式  

主要应用场景： 缓存、计数器、分布式锁、排行榜、简单队列、并集交集

# Redis数据类型

## string

string类型是二进制安全的，string可以包含任何数据如数字、字符串、图片。

Redis中对于浮点数类型也是作为字符串保存的，在需要的时候再将其转换成浮点数类型。


## list

redis用双向链表来实现list

## set

set是string类型的无序集合，集合成员是唯一的。
redis用哈希表来实现set

## hash

Redis hash 是一个 string 类型的 field（字段） 和 value（值） 的映射表，hash 特别适合用于存储对象。


## zset 有序集合

Redis 有序集合和集合一样也是 string 类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个 double 类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序。

zset是通过字典和跳表实现的。 字典方便直接查找，跳表方便范围查找。


## hyperLogLogs 基数统计

可以非常省内存的去处各种计数 

## bigMap 位存储

Bitmap 即位图数据结构，都是操作二进制位来进行记录，只有0 和 1 两个状态。

## geospatial 地理位置


# redis Object

redisObject 是 Redis 类型系统的核心, 数据库中的每个键、值, 以及 Redis 本身处理的参数, 都表示为这种数据类型.

type: 记录了对象所保存的值的类型

encoding: 记录了对象所保存的值的编码

ptr: 指针，指向实际保存值的数据结构


# redis处理一条命令的过程

1. 根据给定的key，在数据库字典中查找和他相对应的redisObject，如果没找到，就返回NULL；
2. 检查redisObject的type属性和执行命令所需的类型是否相符，如果不相符，返回类型错误；
3. 根据redisObject的encoding属性所指定的编码，选择合适的操作函数来处理底层的数据结构；
4. 返回数据结构的操作结果作为命令的返回值。

# 引用计数及对象的销毁

1. 每个redisObject结构都带有一个refcount属性，指示这个对象被引用了多少次；
2. 当新创建一个对象时，它的refcount属性被设置为1；当对一个对象进行共享时，redis将这个对象的refcount加一；
3. 当使用完一个对象后，或者消除对一个对象的引用之后，程序将对象的refcount减一；
4. 当对象的refcount降至0 时，这个RedisObject结构，以及它引用的数据结构的内存都会被释放


# redis底层数据结构

## SDS

Redis 是用 C 语言写的，但是对于Redis的字符串，却不是 C 语言中的字符串（即以空字符’\0’结尾的字符数组），它是自己构建了一种名为 简单动态字符串（simple dynamic string,SDS）的抽象类型，并将 SDS 作为 Redis的默认字符串表示。

SDS包括头部、数据和\0

为什么使用SDS而不是用C语言的字符串？  
1. 常数复杂度获取字符串长度  
2. 支持空间扩展，杜绝缓冲区溢出  
3. 减少修改字符串的内存重新分配次数（空间预分配和惰性空间释放） 
4. 二进制安全
5. 以\0结尾，兼容C字符串函数

## 压缩列表 ZipList

ziplist是为了提高存储效率而设计的一种特殊编码的双向链表。它可以存储字符串或者整数，存储整数时是采用整数的二进制而不是字符串形式存储。它能在O(1)的时间复杂度下完成list两端的push和pop操作。但是因为每次操作都需要重新分配ziplist的内存，所以实际复杂度和ziplist的内存使用量相关。

ziplist尽量让每个元素按实际的内容大小存储，这也是为什么它特别声内存。

ziplist的缺点是不会预留内存空间，并且在移除时会立即缩容， 另外节点的扩容可能会导致链式扩容。


## 快表 QuickList

它是一种以ziplist为结点的双端链表结构. 宏观上, quicklist是一个链表, 微观上, 链表中的每个结点都是一个ziplist。

## 字典/哈希表 Dict

本质就是哈希表

## 整数集 IntSet

整数集合（intset）是集合类型的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis 就会使用整数集合作为集合键的底层实现。

当在一个int16类型的整数集合中插入一个int32类型的值，整个集合的所有元素都会转换成32类型

## 跳表 ZSkipList

跳跃表结构在 Redis 中的运用场景只有一个，那就是作为有序列表 (Zset) 的使用。跳跃表的性能可以保证在查找，删除，添加等操作的时候在对数期望时间内完成，这个性能是可以和平衡树来相比较的，而且在实现方面比平衡树要优雅，这就是跳跃表的长处。跳跃表的缺点就是需要的存储空间比较大，属于利用空间来换取时间的数据结构。#

跳表不支持范围查找，相对平衡树而言，插入和删除不会引发子树的调整，只需要修改相邻节点的指针，操作简单又快速。


# Redis持久化  RDB和AOF

## RDB

RDB 就是 Redis DataBase 的缩写，中文名为快照/内存快照，RDB持久化是把当前进程数据生成快照保存到磁盘上的过程，由于是某一时刻的快照，那么快照中的值要早于或者等于内存中的值。

触发rdb持久化的方式有2种，分别是手动触发和自动触发。

手动触发分别对应save和bgsave命令

自动触发可配置出发规则，也会在主从复制和shutdown命令时自动触发。

RDB中的核心思路是Copy-on-Write，来保证在进行快照操作的这段时间，需要压缩写入磁盘上的数据在内存中不会发生变化。在正常的快照操作中，一方面Redis主进程会fork一个新的快照进程专门来做这个事情，这样保证了Redis服务不会停止对客户端包括写请求在内的任何响应。另一方面这段时间发生的数据变化会以副本的方式存放在另一个新的内存区域，待快照操作结束后才会同步到原来的内存区域。

在进行快照操作的这段时间，如果发生服务崩溃怎么办？

很简单，在没有将数据全部写入到磁盘前，这次快照操作都不算成功。如果出现了服务崩溃的情况，将以上一次完整的RDB快照文件作为恢复内存数据的参考。也就是说，在快照操作过程中不能影响上一次的备份数据。Redis服务会在磁盘上创建一个临时文件进行数据操作，待操作成功后才会用这个临时文件替换掉上一次的备份。

优点： 
	RDB文件是某个时间节点的快照，默认使用LZF算法进行压缩，压缩后的文件体积远远小于内存大小，适用于备份、全量复制等场景；  
	Redis加载RDB文件恢复数据要远远快于AOF方式；

缺点：
	RDB方式实时性不够，无法做到秒级的持久化；  
	每次调用bgsave都需要fork子进程，fork子进程属于重量级操作，频繁执行成本较高；  
	RDB文件是二进制的，没有可读性，AOF文件在了解其结构的情况下可以手动修改或者补全；  
	版本兼容RDB文件问题；

## AOF

Redis是“写后”日志，Redis先执行命令，把数据写入内存，然后才记录日志。日志里记录的是Redis收到的每一条命令，这些命令是以文本形式保存。PS: 大多数的数据库采用的是写前日志（WAL），例如MySQL，通过写前日志和两阶段提交，实现数据和逻辑的一致性。

为什么采用写后日志？
	避免命令检查开销  
	不会阻塞当前的写操作  
	但如果命令执行完成，写日志之前宕机了会造成数据丢失。
	主线程写磁盘压力大会导致写慢，阻塞后速操作。

AOF回写策略（aof_buf缓冲区和aof文件的同步）
	Always 同步回写  
	Eversec	每秒回写  
	No 操作系统控制回写  

默认情况下redis没有开启AOF，需要的redis.conf中配置 


AOF会记录每个写命令到AOF文件，随着时间越来越长，AOF文件会变得越来越大。如果不加以控制，会对Redis服务器，甚至对操作系统造成影响，而且AOF文件越大，数据恢复也越慢。为了解决AOF文件体积膨胀的问题，Redis提供AOF文件重写机制来对AOF文件进行“瘦身”。

AOF重写会阻塞吗？ 
	AOF重写过程是由后台进程bgrewriteaof来完成的。主线程fork出后台的bgrewriteaof子进程，fork会把主线程的内存拷贝一份给bgrewriteaof子进程，这里面就包含了数据库的最新数据。然后，bgrewriteaof子进程就可以在不影响主线程的情况下，逐一把拷贝的数据写成操作，记入重写日志。所以aof在重写时，在fork进程时是会阻塞住主线程的。

为什么AOF重写不复用原AOF日志？  
	父子进程写同一个文件会产生竞争问题，影响父进程的性能。
	如果AOF重写过程中失败了，相当于污染了原本的AOF文件，无法做恢复数据使用。


## RDB + AOF 持久化 

	redis重启时判断是否开启aof，如果开启了aof，那么就优先加载aof文件；  
	如果aof存在，那么就去加载aof文件，加载成功的话redis重启成功，如果aof文件加载失败，那么会打印日志表示启动失败，此时可以去修复aof文件后重新启动；  
	若aof文件不存在，那么redis就会转而去加载rdb文件，如果rdb文件不存在，redis直接启动成功；
	如果rdb文件存在就会去加载rdb文件恢复数据，如加载失败则打印日志提示启动失败，如加载成功，那么redis重启成功，且使用rdb文件恢复数据；

aof保存的数据更加完整


# Redis事件

## 文件事件

Redis的瓶颈主要在IO而不是CPU，所以为了省开发量，在6.0版本前是单线程模型；其次，Redis 是单线程主要是指 Redis 的网络 IO 和键值对读写是由一个线程来完成的，这也是 Redis 对外提供键值存储服务的主要流程。（但 Redis 的其他功能，比如持久化、异步删除、集群数据同步等，其实是由额外的线程执行的）。

Redis 采用了多路复用机制使其在网络 IO 操作中能并发处理大量的客户端请求，实现高吞吐率。在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听套接字和已连接套接字。内核会一直监听这些套接字上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果。

基于多路复用的Redis高性能IO模型为了在请求到达时能通知到 Redis 线程，select/epoll 提供了基于事件的回调机制，即针对不同事件的发生，调用相应的处理函数。那么，回调机制是怎么工作的呢？其实，select/epoll 一旦监测到 FD 上有请求到达时，就会触发相应的事件。这些事件会被放进一个事件队列，Redis 单线程对该事件队列不断进行处理。这样一来，Redis 无需一直轮询是否有请求实际发生，这就可以避免造成 CPU 资源浪费。同时，Redis 在对事件队列中的事件进行处理时，会调用相应的处理函数，这就实现了基于事件的回调。因为 Redis 一直在对事件队列进行处理，所以能及时响应客户端请求，提升 Redis 的响应性能。


## 时间事件

Redis 的时间事件分为以下两类：

	定时事件：让一段程序在指定的时间之后执行一次。  
	周期性事件：让一段程序每隔指定时间就执行一次。  


# Redis事务

Redis 事务的本质是一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。总结说：redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。

## watch命令

WATCH 命令可以为 Redis 事务提供 check-and-set （CAS）行为。

redis支持事务， 在 Redis 中使用 watch 命令可以决定事务是执行还是回滚。

一般而言，可以在 multi 命令之前使用 watch 命令监控某些键值对，然后使用 multi 命令开启事务，执行各类对数据结构进行操作的命令，这个时候这些命令就会进入队列。   

当 Redis 使用 exec 命令执行事务的时候，它首先会去比对被 watch 命令所监控的键值对，  

- 如果没有发生变化，那么它会执行事务队列中的命令，提交事务；  

- 如果发生变化，那么它不会执行任何事务中的命令，而去事务回滚。  

无论事务是否回滚 ， Redis 都会去取消执行事务前的 watch 命令  


实际上这是一种乐观锁的机制。  

## 为什么redis不支持回滚

Redis 命令只会因为错误的语法而失败（并且这些问题不能在入队时发现），或是命令用在了错误类型的键上面：这也就是说，从实用性的角度来说，失败的命令是由编程错误造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中。  
因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。


## 如何理解redis事务与ACID

原子性atomicity  
首先通过上文知道 运行期的错误是不会回滚的，很多文章由此说Redis事务违背原子性的；而官方文档认为是遵从原子性的。Redis官方文档给的理解是，Redis的事务是原子性的：所有的命令，要么全部执行，要么全部不执行。而不是完全成功。
一致性consistency  
redis事务可以保证命令失败的情况下得以回滚，数据能恢复到没有执行之前的样子，是保证一致性的，除非redis进程意外终结。  
隔离性Isolationredis  
事务是严格遵守隔离性的，原因是redis是单进程单线程模式(v6.0之前），可以保证命令执行过程中不会被其他客户端命令打断。但是，Redis不像其它结构化数据库有隔离级别这种设计。
持久性Durability  
redis事务是不保证持久性的，这是因为redis持久化策略中不管是RDB还是AOF都是异步执行的，不保证持久性是出于对性能的考虑。


# 主从复制

## 全量复制

1. 建立连接，协商同步

2. 主库发送RDB文件给同步

3. 主库发送新写命令给从苦  


## 增量复制

找到增量起始点，开始复制，为了满足全量复制中断避免重新开始的场景。


## 为什么主从全量复制使用RDB而不是AOF

1、RDB文件内容是经过压缩的二进制数据（不同数据类型数据做了针对性优化），文件很小。而AOF文件记录的是每一次写操作的命令，写操作越多文件会变得很大，其中还包括很多对同一个key的多次冗余操作。在主从全量数据同步时，传输RDB文件可以尽量降低对主库机器网络带宽的消耗，从库在加载RDB文件时，一是文件小，读取整个文件的速度会很快，二是因为RDB文件存储的都是二进制数据，从库直接按照RDB协议解析还原数据即可，速度会非常快，而AOF需要依次重放每个写命令，这个过程会经历冗长的处理逻辑，恢复速度相比RDB会慢得多，所以使用RDB进行主从全量复制的成本最低。  
2、假设要使用AOF做全量复制，意味着必须打开AOF功能，打开AOF就要选择文件刷盘的策略，选择不当会严重影响Redis性能。而RDB只有在需要定时备份和主从全量复制数据时才会触发生成一次快照。而在很多丢失数据不敏感的业务场景，其实是不需要开启AOF的。



# 高可用-哨兵机制

Redis Sentinel，即Redis哨兵，在Redis 2.8版本开始引入。哨兵的核心功能是主节点的自动故障转移。

## 哨兵功能

监控（Monitoring）：哨兵会不断地检查主节点和从节点是否运作正常。  
自动故障转移（Automatic failover）：当主节点不能正常工作时，哨兵会开始自动故障转移操作，它会将失效主节点的其中一个从节点升级为新的主节点，并让其他从节点改为复制新的主节点。  
配置提供者（Configuration provider）：客户端在初始化时，通过连接哨兵来获得当前Redis服务的主节点地址。  
通知（Notification）：哨兵可以将故障转移的结果发送给客户端。  
 

## 主库下线的判定 

主观下线：任何一个哨兵都是可以监控探测，并作出Redis节点下线的判断；  
客观下线：有哨兵集群共同决定Redis节点是否下线；  
由哨兵集群进行投票，如果赞成票数大于等于哨兵配置文件的quorum配置项，就可以判定主库客观下线了。


## 哨兵集群的选举  

任何一个想成为 Leader 的哨兵，要满足两个条件：
	第一，拿到半数以上的赞成票；   
	第二，拿到的票数同时还需要大于等于哨兵配置文件中的 quorum 值。  

## 选出新的主库

	过滤掉不健康的（下线或断线），没有回复过哨兵ping响应的从节点  
	选择salve-priority从节点优先级最高（redis.conf）的  
	选择复制偏移量最大，只复制最完整的从节点  


## 故障的转移  

新的主库选出后，就可以进行故障转移了。  

1. 被选中的主库脱离原从节点，升级主节点。  
2. 原从节点指向新的主节点。  
3. 通知客户端主节点已更换。  
4. 将原主节点变成从节点，指向新的主节点。  

# redis缓存问题

## 缓存穿透  

缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求。由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。在流量大时，可能DB就挂掉了，要是有人利用不存在的key频繁攻击我们的应用，这就是漏洞。

解决方案： 接口层增加校验、布隆过滤器  

## 缓存击穿  

缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。


解决方案： 热点数据用户过期、接口限流与熔断降级、加互斥锁 

## 缓存雪崩

缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。和缓存击穿不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。


解决方案： 设置缓存数据过期时间随机，避免同一时间大量过期、热点数据永不过期、热点数据均匀分布在不同的缓存数据库中。

## 缓存污染

缓存污染问题说的是缓存中一些只会被访问一次或者几次的的数据，被访问完后，再也不会被访问到，但这部分数据依然留存在缓存中，消耗缓存空间。


## redis删除策略

- 到达maxmemory,触发删除

- 被动删除到达过期时间的key（惰性删除）

- 主动删除到达过期时间的key （主动删除）


## redis淘汰策略

### 不淘汰

### 对设置了过期时间的数据进行淘汰  

随机  
ttl  
lru  
lfu


### 全部数据进行淘汰

随机  
lru  
lfu  


# 数据库和缓存一致性

## cache aside pattern

- 读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。
- 更新的时候，先更新数据库，然后再删除缓存。

## 利用消息队列异步删除缓存


# redis 监控

查看状态： info  

监控收到的命令： monitor  


# reids性能调优 （redis太慢有哪些原因？）

## 命令复杂度过高  

用scan 它们每次执行都只会返回少量元素， 所以这些命令可以用于生产环境， 而不会出现像 KEYS 命令、 SMEMBERS 命令带来的问题 —— 当 KEYS 命令被用于处理一个大的数据库时， 又或者 SMEMBERS 命令被用于处理一个大的集合键时， 它们可能会阻塞服务器达数秒之久。
SORT命令时间复杂度O(N)以上。


## 操作big key  

## 集中过期  

## 实例内存达到上限 

使用的数据内存达到了最大值

## 请求数达到了redis上限。

## fork耗时严重  

当 Redis 开启了后台 RDB 和 AOF rewrite 后，在执行时，它们都需要主进程创建出一个子进程进行数据的持久化。

主进程创建子进程，会调用操作系统提供的 fork 函数。

## 操作系统开启内存大页

## 开启AOF  

## 网络带宽过载






# 友情链接 

 [redis知识体系](https://pdai.tech/md/db/nosql-redis/db-redis-overview.html)
 






