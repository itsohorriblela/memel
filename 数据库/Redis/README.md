# Redis优点

1. 读写性能优异  
2. 数据类型丰富  
3. Redis的所有操作都是原子性的，同时Redis还支持对几个操作一起的原子性执行  
4. 丰富的特性，支持发布订阅，key过期  
5. 分布式  

主要应用场景： 缓存、计数器、分布式锁、排行榜、简单队列、并集交集

# Redis数据类型

## string

string类型是二进制安全的，string可以包含任何数据如数字、字符串、图片。

Redis中对于浮点数类型也是作为字符串保存的，在需要的时候再将其转换成浮点数类型。


## list

redis用双向链表来实现list

## set

set是string类型的无序集合，集合成员是唯一的。
redis用哈希表来实现set

## hash

Redis hash 是一个 string 类型的 field（字段） 和 value（值） 的映射表，hash 特别适合用于存储对象。


## zset 有序集合

Redis 有序集合和集合一样也是 string 类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个 double 类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序。

zset是通过字典和跳表实现的。 字典方便直接查找，跳表方便范围查找。


## hyperLogLogs 基数统计

可以非常省内存的去处各种计数 

## bigMap 位存储

Bitmap 即位图数据结构，都是操作二进制位来进行记录，只有0 和 1 两个状态。

## geospatial 地理位置


# redis Object

redisObject 是 Redis 类型系统的核心, 数据库中的每个键、值, 以及 Redis 本身处理的参数, 都表示为这种数据类型.

type: 记录了对象所保存的值的类型

encoding: 记录了对象所保存的值的编码

ptr: 指针，指向实际保存值的数据结构


# redis处理一条命令的过程

1. 根据给定的key，在数据库字典中查找和他相对应的redisObject，如果没找到，就返回NULL；
2. 检查redisObject的type属性和执行命令所需的类型是否相符，如果不相符，返回类型错误；
3. 根据redisObject的encoding属性所指定的编码，选择合适的操作函数来处理底层的数据结构；
4. 返回数据结构的操作结果作为命令的返回值。

# 引用计数及对象的销毁

1. 每个redisObject结构都带有一个refcount属性，指示这个对象被引用了多少次；
2. 当新创建一个对象时，它的refcount属性被设置为1；当对一个对象进行共享时，redis将这个对象的refcount加一；
3. 当使用完一个对象后，或者消除对一个对象的引用之后，程序将对象的refcount减一；
4. 当对象的refcount降至0 时，这个RedisObject结构，以及它引用的数据结构的内存都会被释放


# redis底层数据结构

## SDS

Redis 是用 C 语言写的，但是对于Redis的字符串，却不是 C 语言中的字符串（即以空字符’\0’结尾的字符数组），它是自己构建了一种名为 简单动态字符串（simple dynamic string,SDS）的抽象类型，并将 SDS 作为 Redis的默认字符串表示。

SDS包括头部、数据和\0

为什么使用SDS而不是用C语言的字符串？  
1. 常数复杂度获取字符串长度  
2. 支持空间扩展，杜绝缓冲区溢出  
3. 减少修改字符串的内存重新分配次数（空间预分配和惰性空间释放） 
4. 二进制安全
5. 以\0结尾，兼容C字符串函数

## 压缩列表 ZipList

ziplist是为了提高存储效率而设计的一种特殊编码的双向链表。它可以存储字符串或者整数，存储整数时是采用整数的二进制而不是字符串形式存储。它能在O(1)的时间复杂度下完成list两端的push和pop操作。但是因为每次操作都需要重新分配ziplist的内存，所以实际复杂度和ziplist的内存使用量相关。

ziplist尽量让每个元素按实际的内容大小存储，这也是为什么它特别省内存。

ziplist的缺点是不会预留内存空间，并且在移除时会立即缩容， 另外节点的扩容可能会导致链式扩容。


## 快表 QuickList

它是一种以ziplist为结点的双端链表结构. 宏观上, quicklist是一个链表, 微观上, 链表中的每个结点都是一个ziplist。

## 字典/哈希表 Dict

本质就是哈希表

## 整数集 IntSet

整数集合（intset）是集合类型的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis 就会使用整数集合作为集合键的底层实现。

当在一个int16类型的整数集合中插入一个int32类型的值，整个集合的所有元素都会转换成32类型

## 跳表 ZSkipList

跳跃表结构在 Redis 中的运用场景只有一个，那就是作为有序列表 (Zset) 的使用。跳跃表的性能可以保证在查找，删除，添加等操作的时候在对数期望时间内完成，这个性能是可以和平衡树来相比较的，而且在实现方面比平衡树要优雅，这就是跳跃表的长处。跳跃表的缺点就是需要的存储空间比较大，属于利用空间来换取时间的数据结构。

跳表支持范围查找，相对平衡树而言，插入和删除不会引发子树的调整，只需要修改相邻节点的指针，操作简单又快速。



# Redis持久化  RDB和AOF

## RDB

RDB 就是 Redis DataBase 的缩写，中文名为快照/内存快照，RDB持久化是把当前进程数据生成快照保存到磁盘上的过程，由于是某一时刻的快照，那么快照中的值要早于或者等于内存中的值。

### 触发rdb持久化的方式有2种，分别是手动触发和自动触发。

手动触发分别对应save和bgsave命令

自动触发可配置出发规则，也会在主从复制和shutdown命令时自动触发。

RDB中的核心思路是Copy-on-Write，来保证在进行快照操作的这段时间，需要压缩写入磁盘上的数据在内存中不会发生变化。在正常的快照操作中，一方面Redis主进程会fork一个新的快照进程专门来做这个事情，这样保证了Redis服务不会停止对客户端包括写请求在内的任何响应。另一方面这段时间发生的数据变化会以副本的方式存放在另一个新的内存区域，待快照操作结束后才会同步到原来的内存区域。

在进行快照操作的这段时间，如果发生服务崩溃怎么办？

很简单，在没有将数据全部写入到磁盘前，这次快照操作都不算成功。如果出现了服务崩溃的情况，将以上一次完整的RDB快照文件作为恢复内存数据的参考。也就是说，在快照操作过程中不能影响上一次的备份数据。Redis服务会在磁盘上创建一个临时文件进行数据操作，待操作成功后才会用这个临时文件替换掉上一次的备份。

优点： 
	RDB文件是某个时间节点的快照，默认使用LZF算法进行压缩，压缩后的文件体积远远小于内存大小，适用于备份、全量复制等场景；  
	Redis加载RDB文件恢复数据要远远快于AOF方式；

缺点：
	RDB方式实时性不够，无法做到秒级的持久化；  
	每次调用bgsave都需要fork子进程，fork子进程属于重量级操作，频繁执行成本较高；  
	RDB文件是二进制的，没有可读性，AOF文件在了解其结构的情况下可以手动修改或者补全；  
	版本兼容RDB文件问题；

## AOF

Redis是“写后”日志，Redis先执行命令，把数据写入内存，然后才记录日志。日志里记录的是Redis收到的每一条命令，这些命令是以文本形式保存。PS: 大多数的数据库采用的是写前日志（WAL），例如MySQL，通过写前日志和两阶段提交，实现数据和逻辑的一致性。

### 为什么采用写后日志？

	避免命令检查开销  
	不会阻塞当前的写操作  
	但如果命令执行完成，写日志之前宕机了会造成数据丢失。
	写前日志主线程写磁盘压力大会导致写慢，阻塞后续操作。

### AOF回写策略（aof_buf缓冲区和aof文件的同步）

	Always 同步回写  
	Eversec	每秒回写  
	No 操作系统控制回写  

默认情况下redis没有开启AOF，需要的redis.conf中配置 

### AOF重写

AOF会记录每个写命令到AOF文件，随着时间越来越长，AOF文件会变得越来越大。如果不加以控制，会对Redis服务器，甚至对操作系统造成影响，而且AOF文件越大，数据恢复也越慢。为了解决AOF文件体积膨胀的问题，Redis提供AOF文件重写机制来对AOF文件进行“瘦身”。

AOF重写会阻塞吗？ 

	AOF重写过程是由后台进程bgrewriteaof来完成的。主线程fork出后台的bgrewriteaof子进程，fork会把主线程的内存拷贝一份给bgrewriteaof子进程，这里面就包含了数据库的最新数据。然后，bgrewriteaof子进程就可以在不影响主线程的情况下，逐一把拷贝的数据写成操作，记入重写日志。所以aof在重写时，在fork进程时是会阻塞住主线程的。

为什么AOF重写不复用原AOF日志？  
	父子进程写同一个文件会产生竞争问题，影响父进程的性能。
	如果AOF重写过程中失败了，相当于污染了原本的AOF文件，无法做恢复数据使用。


## RDB + AOF 持久化 

	redis重启时判断是否开启aof，如果开启了aof，那么就优先加载aof文件；  
	如果aof存在，那么就去加载aof文件，加载成功的话redis重启成功，如果aof文件加载失败，那么会打印日志表示启动失败，此时可以去修复aof文件后重新启动；  
	若aof文件不存在，那么redis就会转而去加载rdb文件，如果rdb文件不存在，redis直接启动成功；
	如果rdb文件存在就会去加载rdb文件恢复数据，如加载失败则打印日志提示启动失败，如加载成功，那么redis重启成功，且使用rdb文件恢复数据；

aof保存的数据更加完整


# Redis事件

## 文件事件（redis为什么是单线程，单线程为什么快？）

redis单线程主要是指Redis的网络IO和键值对读写是由一个线程来完成的

Redis的瓶颈主要在IO而不是CPU，所以为了省开发量，在6.0版本前是单线程模型；其次，Redis 是单线程主要是指 Redis 的网络 IO 和键值对读写是由一个线程来完成的，这也是 Redis 对外提供键值存储服务的主要流程。（但 Redis 的其他功能，比如持久化、异步删除、集群数据同步等，其实是由额外的线程执行的）。

Redis 采用了多路复用机制使其在网络 IO 操作中能并发处理大量的客户端请求，实现高吞吐率。在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听套接字和已连接套接字。内核会一直监听这些套接字上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果。

基于多路复用的Redis高性能IO模型为了在请求到达时能通知到 Redis 线程，select/epoll 提供了基于事件的回调机制，即针对不同事件的发生，调用相应的处理函数。那么，回调机制是怎么工作的呢？其实，select/epoll 一旦监测到 FD 上有请求到达时，就会触发相应的事件。这些事件会被放进一个事件队列，Redis 单线程对该事件队列不断进行处理。这样一来，Redis 无需一直轮询是否有请求实际发生，这就可以避免造成 CPU 资源浪费。同时，Redis 在对事件队列中的事件进行处理时，会调用相应的处理函数，这就实现了基于事件的回调。因为 Redis 一直在对事件队列进行处理，所以能及时响应客户端请求，提升 Redis 的响应性能。


## 时间事件

Redis 的时间事件分为以下两类：

	定时事件：让一段程序在指定的时间之后执行一次。  
	周期性事件：让一段程序每隔指定时间就执行一次。  


# Redis事务

Redis 事务的本质是一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。总结说：redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。

## watch命令

WATCH 命令可以为 Redis 事务提供 check-and-set （CAS）行为。

redis支持事务， 在 Redis 中使用 watch 命令可以决定事务是执行还是回滚。

一般而言，可以在 multi 命令之前使用 watch 命令监控某些键值对，然后使用 multi 命令开启事务，执行各类对数据结构进行操作的命令，这个时候这些命令就会进入队列。   

当 Redis 使用 exec 命令执行事务的时候，它首先会去比对被 watch 命令所监控的键值对，  

- 如果没有发生变化，那么它会执行事务队列中的命令，提交事务；  

- 如果发生变化，那么它不会执行任何事务中的命令，而去事务回滚。  

无论事务是否回滚 ， Redis 都会去取消执行事务前的 watch 命令  


实际上这是一种乐观锁的机制。  

## 为什么redis不支持命令回滚

Redis 命令只会因为错误的语法而失败（并且这些问题不能在入队时发现），或是命令用在了错误类型的键上面：这也就是说，从实用性的角度来说，失败的命令是由编程错误造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中。  
因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。


## 如何理解redis事务与ACID

原子性atomicity  
首先通过上文知道 运行期的错误是不会回滚的，很多文章由此说Redis事务违背原子性的；而官方文档认为是遵从原子性的。Redis官方文档给的理解是，Redis的事务是原子性的：所有的命令，要么全部执行，要么全部不执行。而不是完全成功。

一致性consistency  
redis事务可以保证命令失败的情况下得以回滚，数据能恢复到没有执行之前的样子，是保证一致性的，除非redis进程意外终结。

隔离性Isolationredis  
事务是严格遵守隔离性的，原因是redis是单进程单线程模式(v6.0之前），可以保证命令执行过程中不会被其他客户端命令打断。但是，Redis不像其它结构化数据库有隔离级别这种设计。

持久性Durability  
redis事务是不保证持久性的，这是因为redis持久化策略中不管是RDB还是AOF都是异步执行的，不保证持久性是出于对性能的考虑。


# 主从复制

## 全量复制

1. 建立连接，协商同步

2. 主库发送RDB文件给同步

3. 主库发送新写命令给从库


## 增量复制

找到增量起始点，开始复制，为了满足全量复制中断避免重新开始的场景。


## 为什么主从全量复制使用RDB而不是AOF

1、RDB文件内容是经过压缩的二进制数据（不同数据类型数据做了针对性优化），文件很小。而AOF文件记录的是每一次写操作的命令，写操作越多文件会变得很大，其中还包括很多对同一个key的多次冗余操作。在主从全量数据同步时，传输RDB文件可以尽量降低对主库机器网络带宽的消耗，从库在加载RDB文件时，一是文件小，读取整个文件的速度会很快，二是因为RDB文件存储的都是二进制数据，从库直接按照RDB协议解析还原数据即可，速度会非常快，而AOF需要依次重放每个写命令，这个过程会经历冗长的处理逻辑，恢复速度相比RDB会慢得多，所以使用RDB进行主从全量复制的成本最低。  
2、假设要使用AOF做全量复制，意味着必须打开AOF功能，打开AOF就要选择文件刷盘的策略，选择不当会严重影响Redis性能。而RDB只有在需要定时备份和主从全量复制数据时才会触发生成一次快照。而在很多丢失数据不敏感的业务场景，其实是不需要开启AOF的。


# Redis集群

主从复制与哨兵，这两个机制保障了redis的高可用，但实际使用中会发现虽然slave节点扩展了整个系统的的读并发能力，但是写能力和存储能力是无法进行扩展，就只能是master节点能够承载的上限。
如果面对海量数据那么必然需要构建master（主节点分片，每个分片只保存一部分数据)之间的集群，同时必然需要吸收高可用（主从复制和哨兵机制）能力，即每个master分片节点还需要有slave节点


# Redis扩容

## 两种方式

- 水平扩容： 通过增加更多的Redis服务器来分摊数据和负载。数据将被分散（分片）存储到多个Redis实例中，每个实例只存储整个数据的一部分。Redis本身不支持自动分片，需要在客户端实现分片逻辑。此外，Redis Cluster提供了自动分片和高可用性的解决方案。

- 垂直扩容： 通过增加单个Redis服务器的硬件资源（如RAM、CPU等）来提升其性能和容量。这种方式的缺点是硬件资源是有上限的，无法无限扩容。

## 动态扩容

Redis的动态扩容通常指的是在Redis集群（Cluster）环境下，不需要停止服务或者重启系统就能够增加或者减少节点的操作，以便于系统可以按照实际的需求和负载进行扩展或收缩。

一致性哈希是一种经典的分片算法。

一致性哈希（Consistent Hashing）和动态扩容（Dynamic scaling）在分布式系统中都是重要的概念。一致性哈希是一种特殊的哈希技术，而动态扩容是对分布式系统进行资源调整的策略。

一致性哈希是一种特殊的哈希算法，通过这种算法，当集群的机器数量发生变化时，能最小化重新映射的键值对数量，这对于缓存系统（如Redis）来说尤为重要。在传统的哈希算法中，如果机器数量发生变化，所有的键值对都需要重新映射，这通常会造成大量的缓存失效，导致系统负载骤增。而一致性哈希则通过在哈希环上平均分配节点，并将数据映射到相应的节点上，从而最小化这种影响。

动态扩容（或者缩容）是指根据系统的负载情况，实时地增加或减少服务器的数量。这就需要能够在扩容或缩容的时候，快速并且准确地重新分配数据，以便使得系统的负载能够均匀地分配到所有的服务器上。这就是一致性哈希发挥作用的地方。

因此，我们可以说一致性哈希和动态扩容是相辅相成的。一致性哈希为动态扩容提供了高效的数据重新分配的算法，而动态扩容则需要依赖一致性哈希来完成数据的快速重新分配。




# 高可用-哨兵机制

Redis Sentinel，即Redis哨兵，在Redis 2.8版本开始引入。哨兵的核心功能是主节点的自动故障转移。

## 哨兵功能

- 监控（Monitoring）：哨兵会不断地检查主节点和从节点是否运作正常。  
- 自动故障转移（Automatic failover）：当主节点不能正常工作时，哨兵会开始自动故障转移操作，它会将失效主节点的其中一个从节点升级为新的主节点，并让其他从节点改为复制新的主节点。  
- 配置提供者（Configuration provider）：客户端在初始化时，通过连接哨兵来获得当前Redis服务的主节点地址。  
- 通知（Notification）：哨兵可以将故障转移的结果发送给客户端。  
 

## 主库下线的判定 

主观下线：任何一个哨兵都是可以监控探测，并作出Redis节点下线的判断； 

客观下线：由哨兵集群共同决定Redis节点是否下线；  

由哨兵集群进行投票，如果赞成票数大于等于哨兵配置文件的quorum配置项，就可以判定主库客观下线了。


## 哨兵集群的选举  

任何一个想成为 Leader 的哨兵，要满足两个条件：
	第一，拿到半数以上的赞成票；   
	第二，拿到的票数同时还需要大于等于哨兵配置文件中的 quorum 值。  

## 选出新的主库

	过滤掉不健康的（下线或断线），没有回复过哨兵ping响应的从节点  
	选择salve-priority从节点优先级最高（redis.conf）的  
	选择复制偏移量最大，只复制最完整的从节点  


## 故障的转移  

新的主库选出后，就可以进行故障转移了。  

1. 被选中的主库脱离原从节点，升级主节点。  
2. 原从节点指向新的主节点。  
3. 通知客户端主节点已更换。  
4. 将原主节点变成从节点，指向新的主节点。  



# redis缓存问题

## 缓存穿透  

缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求。由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。在流量大时，可能DB就挂掉了，要是有人利用不存在的key频繁攻击我们的应用，这就是漏洞。

解决方案： 接口层增加校验、布隆过滤器  

## 缓存击穿  

缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。


解决方案： 热点数据永不过期、接口限流与熔断降级、加互斥锁 

## 缓存雪崩

缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。和缓存击穿不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。


解决方案： 设置缓存数据过期时间随机，避免同一时间大量过期、热点数据永不过期、热点数据均匀分布在不同的缓存数据库中。

## 缓存污染

缓存污染问题说的是缓存中一些只会被访问一次或者几次的的数据，被访问完后，再也不会被访问到，但这部分数据依然留存在缓存中，消耗缓存空间。


## redis删除策略

- 到达maxmemory,触发删除

- 被动删除到达过期时间的key（惰性删除）

- 主动删除到达过期时间的key （主动删除）


## redis淘汰策略

### 不淘汰

### 对设置了过期时间的数据进行淘汰  

随机  
ttl  
lru  
lfu


### 全部数据进行淘汰

随机  
lru  
lfu  



# redis 监控

查看状态： info  

监控收到的命令： monitor  


# reids性能调优 （redis太慢有哪些原因？）

## 命令复杂度过高  

用scan 它们每次执行都只会返回少量元素， 所以这些命令可以用于生产环境， 而不会出现像 KEYS 命令、 SMEMBERS 命令带来的问题 —— 当 KEYS 命令被用于处理一个大的数据库时， 又或者 SMEMBERS 命令被用于处理一个大的集合键时， 它们可能会阻塞服务器达数秒之久。
SORT命令时间复杂度O(N)以上。


## 操作big key  

## 集中过期  

## 实例内存达到上限 

使用的数据内存达到了最大值

## 请求数达到了redis上限。

## fork耗时严重  

当 Redis 开启了后台 RDB 和 AOF rewrite 后，在执行时，它们都需要主进程创建出一个子进程进行数据的持久化。

主进程创建子进程，会调用操作系统提供的 fork 函数。

## 操作系统开启内存大页

## 开启AOF  

## 网络带宽过载


# redis big Key

通俗易懂的讲，Big Key就是某个key对应的value很大，占用的redis空间很大，本质上是大value问题。key往往是程序可以自行设置的，value往往不受程序控制，因此可能导致value很大。

redis中这些Big Key对应的value值很大，在序列化/反序列化过程中花费的时间很大，因此当我们操作Big Key时，通常比较耗时，这就可能导致redis发生阻塞，从而降低redis性能。

用几个实际的例子对大Key的特征进行描述：

● 一个String类型的Key，它的值为5MB（数据过大）；
● 一个List类型的Key，它的列表数量为20000个（列表数量过多）；
● 一个ZSet类型的Key，它的成员数量为10000个（成员数量过多）；
● 一个Hash格式的Key，它的成员数量虽然只有1000个但这些成员的value总大小为100MB（成员体积过大）；

## big key产生的场景

1. redis数据结构使用不恰当  

将Redis用在并不适合其能力的场景，造成Key的value过大，如使用String类型的Key存放大体积二进制文件型数据。

2. 未及时清理垃圾数据  

没有对无效数据进行定期清理，造成如HASH类型Key中的成员持续不断的增加。即一直往value塞数据，却没有删除机制，value只会越来越大。

3. 对业务预估不准确  

业务上线前规划设计考虑不足没有对Key中的成员进行合理的拆分，造成个别Key中的成员数量过多。

4. 明星、网红的粉丝列表、某条热点新闻的评论列表  

假设我们使用List数据结构保存某个明星/网红的粉丝，或者保存热点新闻的评论列表，因为粉丝数量巨大，热点新闻因为点击率、评论数会很多，这样List集合中存放的元素就会很多，可能导致value过大，进而产生Big Key问题。


## big key危害

1. 阻塞请求  

Big Key对应的value较大，我们对其进行读写的时候，需要耗费较长的时间，这样就可能阻塞后续的请求处理。Redis的核心线程是单线程，单线程中请求任务的处理是串行的，前面的任务完不成，后面的任务就处理不了。

2. 内存增大

读取Big Key耗费的内存比正常Key会有所增大，如果不断变大，可能会引发OOM（内存溢出），或达到redis的最大内存maxmemory设置值引发写阻塞或重要Key被逐出。

3. 阻塞网络

读取单value较大时会占用服务器网卡较多带宽，自身变慢的同时可能会影响该服务器上的其他Redis实例或者应用。

4. 影响主从同步、主从切换

删除一个大Key造成主库较长时间的阻塞并引发同步中断或主从切换。

## 如何识别big key

1. 使用redis自带的命令识别

例如可以使用Redis官方客户端redis-cli加上--bigkeys参数，可以找到某个实例5种数据类型(String、hash、list、set、zset)的最大key。
    优点是可以在线扫描，不阻塞服务；缺点是信息较少，内容不够精确。

2. 使用debug object key命令

根据传入的对象（Key的名称）来对Key进行分析并返回大量数据，其中serializedlength的值为该Key的序列化长度，需要注意的是，Key的序列化长度并不等同于它在内存空间中的真实长度，此外，debug object属于调试命令，运行代价较大，并且在其运行时，进入Redis的其余请求将会被阻塞直到其执行完毕。并且每次只能查找单个key的信息，官方不推荐使用。

## 如何解决 big key 问题

1. 对大Key进行拆分

将一个Big Key拆分为多个key-value这样的小Key，并确保每个key的成员数量或者大小在合理范围内，然后再进行存储，通过get不同的key或者使用mget批量获取。

2. 对大Key进行清理

对Redis中的大Key进行清理，从Redis中删除此类数据。Redis自4.0起提供了UNLINK命令，该命令能够以非阻塞的方式缓慢逐步的清理传入的Key，通过UNLINK，你可以安全的删除大Key甚至特大Key。


3. 监控Redis的内存、网络带宽、超时等指标

通过监控系统并设置合理的Redis内存报警阈值来提醒我们此时可能有大Key正在产生，如：Redis内存使用率超过70%，Redis内存1小时内增长率超过20%等。

4. 定期清理失效数据

如果某个Key有业务不断以增量方式写入大量的数据，并且忽略了其时效性，这样会导致大量的失效数据堆积。可以通过定时任务的方式，对失效数据进行清理。

5. 压缩value

使用序列化、压缩算法将key的大小控制在合理范围内，但是需要注意序列化、反序列化都会带来一定的消耗。如果压缩后，value还是很大，那么可以进一步对key进行拆分。







# redis mysql双写一致性

## 一致性是什么

强一致性：写入什么，读取就是什么

弱一致性：写入之后，经过一定时间级别，数据达到一致

最终一致性：弱一致性的特例，在一定时间内达到一致

严格意义上任何非原子操作都不可能保证一致性，除非用阻塞读写实现强一致性，所以对于缓存架构我们追求的目标是最终一致性。

实际上，缓存就是通过牺牲强一致性来提高性能的。这是由CAP理论决定的。缓存系统适用的场景就是非强一致性的场景，它属于CAP中的AP。


Redis与MySQL双写一致性是指在使用缓存和数据库同时存储数据的场景下( 主要是存在高并发的情况)，如何保证两者的数据一致性（内容相同或者尽可能接近）。

## 如何保证一致

- 通常是先写数据库，后删除缓存

- 延时双删

- redis数据过期

- 通过业务设计加强数据一致性 唯一ID  唯一版本

- 很多时候，数据不一致是因为多个节点并行读写共享数据导致。如果某些特定业务只落在某个进程某个线程上独立 串行 处理，那问题处理是否会更好呢？

## 缓存删除失败怎么办？

	- 后者失败失败重试
	
	- 失败后发送mq消息，mq消费者实现重试，重试超过一定次数，进入死信队列。

    - 订阅binlog加上mq重试机制


## 延时双删

1. 删除redis缓存数据

2. 更新数据库数据

3. 延时执行

4. 删除redis缓存数据

### 作用

为了使得缓存和数据库数据最终一致。，但它不是强一致。

## 缺点

- 延时双删，有等待环节，如果系统要求低延时，这种场景就不合适了。

- 延时双删，不适合“秒杀”这种频繁修改数据和要求数据强一致的场景。

- 延时双删，延时时间是一个预估值，不能确保 mysql 和 redis 数据在这个时间段内都实时同步或持久化成功了。

### 为什么要删除缓存数据，而不是修改？

- 如果是修改，刚改完缓存，没来得及改库，服务进程挂了怎么办。
- 如果是修改，在多个线程/进程/节点改数据场景，先改缓存的有可能后改库，先改库的也可能后改缓存。     

### 为什么要睡眠延时一段时间？

- 读写分离是解决高并发比较有效的方案，但是缓存/库的主从是异步更新数据的。
- 睡眠一段时间，就是为了库和缓存能实现数据主从同步。

### 延时双删能确保缓存和数据库最终一致吗？

- 不能确保。
- 只能通过延时最大程度上提高数据的最终一致的概率。
- 如果缓存和数据库负载很高，主从同步很慢，很有可能不能在延时的时间内实现同步。

### 为什么要有第一次删除缓存？

- 为了能快点实现数据一致。

- 又可能程序改完库后，异常退出了。，没有及时改缓存。


# redis使用单线程的原因以及为什么后来发展了多线程

1. 使用单线程模型是redis开发和维护更加简单。

2. 使用是IO多路复用和非阻塞模型。

3. 对于redis来说，主要的系统瓶颈是内存或者网络并发cpu。

4. 避免上下文切换：因为是单线程模型，因此就避免了不必要的上下文切换和多线程竞争，这就省去了多线程切换带来的时间和性能上的消耗，而且单线程


## 单线程的问题

删除大key时，出现阻塞卡顿问题，针对此问题引入了多线程的异步惰性删除。

## 多线程的发展

在Redis6/7中引入了I/O多线程的读写，增加了吞吐量，而命令的执行依旧是有主线程串行执行的，因此在多线程下操作Redis既能保持良好的性能和响应速度，并且不会出现线程安全的问题。

主要实现思路是将主线程的IO读写任务拆分给一组独立的线程去执行，这样就可以使多个Socket的读写可以并行化了，采用多路I/O复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗)，将最耗时的Socket的读取、请求解析、写入单独外包出去，剩下的命令执行仍然由主线程串行执行并和内存的数据交互。




# 友情链接 

 [redis知识体系](https://pdai.tech/md/db/nosql-redis/db-redis-overview.html)
 






