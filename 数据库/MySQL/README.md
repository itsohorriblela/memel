# 有用的SQL命令

## CONCAT
在 MySQL 中，CONCAT 函数用于将多个字符串连接在一起。它接受两个或多个参数，并返回这些参数连接后的字符串。
SELECT CONCAT('My name is ', first_name, ' ', last_name) AS full_name FROM users;  

## EXPLAIN
EXPLAIN 是 MySQL 数据库提供的一个关键字，用于分析和优化查询语句的执行计划。通过 EXPLAIN，您可以获取有关查询的详细信息，了解 MySQL 在执行查询时所采取的操作和优化策略。

要使用 EXPLAIN，只需在查询语句前加上 EXPLAIN 关键字，然后执行该语句。MySQL 将返回一个描述查询执行计划的结果集，其中包含以下重要的列：

id: 表示查询中每个操作的标识符，主要用于连接操作。  
select_type: 描述查询的类型，例如简单查询、联接查询、子查询等。  
table: 指示查询涉及的表。  
type: 表示每个表的访问方式，例如全表扫描、索引扫描、范围扫描等。  
possible_keys: 表示可能用于查询的索引。  
key: 表示实际选择的索引。  
key_len: 表示索引使用的字节数。  
ref: 表示索引的比较列。  
rows: 表示查询扫描的行数估计值。  
Extra: 提供其他与查询相关的附加信息，如排序操作、临时表使用等。  



# 坑 

## 大小写

MySQL在Linux下数据库名、表名、列名、别名大小写规则是这样的：
1、数据库名与表名是严格区分大小写的；  
2、表的别名是严格区分大小写的；  
3、列名与列的别名在所有的情况下均是忽略大小写的；  
4、字段内容默认情况下是大小写不敏感的。  

InnoDB在创建表时可以设置 COLLATE utf8mb4_bin指定大小写敏感  
`show collation where charset = 'utf8mb4';`
ci结尾为大小写不敏感，bin结尾的是大小写敏感  

## 高并发下更新丢失

两个事务同时更新一行数据，一个事务对数据的更新把另一个事务对数据的更新覆盖了。这是因为系统没有执行任何的锁操作，因此并发事务并没有被隔离开来。

- 第一类丢失更新： A事务撤销时，把已经提交的B事务的更新数据覆盖了。SQL标准中未对此做定义，所有数据库都已解决了第一类丢失更新的问题。

- 第二类丢失更新

A事务覆盖B事务已经提交的数据，造成B事务所做操作丢失。

解决方案

1. 调整SQL语句，将更新赋值逻辑改为“c=c+x”形式，其中c为要更新的字段，x为增量值。这种方式能确保累加值不会被覆盖。

2. 悲观锁：利用redis分布式锁

3. 乐观锁： 增加版本概念，若版本冲突则回退

## 唯一索引

创建唯一索引的字段，都不能允许为null，否则mysql的唯一性约束可能会失效。  


# 基础知识 

## InnoDB在RR级别下如何解决幻读

在RR的隔离级别下，Innodb使用MVCC和next-key locks解决幻读，MVCC解决的是普通读（快照读）的幻读，next-key locks解决的是当前读情况下的幻读。 

### 当前读

所谓当前读，指的是加锁的select(S或者X), update, delete等语句。在RR的事务隔离级别下，数据库会使用next-key locks来锁住本条记录以及索引区间。 

### 普通读

因为普通读是不会加锁的读，故不会有next-key locks的使用，解决幻读的手段是MVCC  

MVCC会给每行元组加一些辅助字段，记录创建版本号和删除版本号。

而每一个事务在启动的时候，都有一个唯一的递增的版本号。每开启一个新事务，事务的版本号就会递增。 

默认的隔离级别（REPEATABLE READ）下，增删查改变成了这样：  

- SELECT

读取创建版本小于或等于当前事务版本号，并且删除版本为空或大于当前事务版本号的记录。这样可以保证在读取之前记录是存在的  

- INSERT

将当前事务的版本号保存至行的创建版本号  

- UPDATE

新插入一行，并以当前事务的版本号作为新行的创建版本号，同时将原记录行的删除版本号设置为当前事务版本号  

- DELETE

将当前事务的版本号保存至行的删除版本号  



## 最左前缀原则

	左前缀原则指的是，如果查询的时候查询条件精确匹配索引的左边连续一列或几列，则此列就可以被用到  
	查询的时候如果两个条件都用上了，但是顺序不同，如 city= xx and name ＝xx，那么现在的查询引擎会自动优化为匹配联合索引的顺序，这样是能够命中索引的。  
	由于最左前缀原则，在创建联合索引时，索引字段的顺序需要考虑字段值去重之后的个数，较多的放前面。ORDER BY子句也遵循此规则。  

    原理： 构建一颗B+树只能根据一个值来构建，因此数据库依据联合索引最左的字段来构建B+树。  


## char、varchar、text的选择

1. char长度固定，char(n)中的n表示字符数，最大长度是255个字符, 即每条数据占用等长字节空间；适合用在身份证号码、手机号码等定。

2. varchar可变长度，varchar(n)中的n表示字符数，最大空间是65535个字节, 可以设置最大长度；适合用在长度可变的属性。

3. text不设置长度， 当不知道属性的最大长度时，适合用text。


## 两阶段提交

1. 写入redo log, 置redo log状态为prepare
2. 写bin log
3. 修改redo log状态为commit

bin log是否完整是事务是否成功的标志

那为什么还需要第三步呢？
如果没有第三步，在判断redo_log和bin_log是否一致时需要全量对比，性能差。

- redo log : 固定大小、循环写的日志文件

- bin log : 无限大小、追加写的日志文件

一条数据首先被写入内存，之后再被写入磁盘。
redo log就是用来记录写入内存但未刷盘的日志，已经刷入磁盘的数据都会从 redo log 这个有限大小的日志文件里删除。  
已经刷入磁盘的数据都会从 redo log 这个有限大小的日志文件里删除。  


当数据库 crash 后，如何恢复未刷盘的数据到内存中？
根据 redo log 和 binlog 的两阶段提交，未持久化的数据分为几种情况：

1. change buffer 写入，redo log 虽然做了 fsync 但未 commit，binlog 未 fsync 到磁盘，这部分数据丢失。

2. change buffer 写入，redo log fsync 未 commit，binlog 已经 fsync 到磁盘，先从 binlog 恢复 redo log，再从 redo log 恢复 change buffer。

3. change buffer 写入，redo log commit 和 binlog 都已经 fsync，直接从 redo log 里恢复。


# MYSQL数据类型中长度的含义

## 字符串类型
CHAR(10) VARCHAR(10)  n表示可容纳的最大字符数

## 整数类型
INT(5) n表示显示位宽，基本没用。

## 浮点数类型
DECIMAL(M, D) M代表最大位数，D表示小数点右侧的位数。  
DECIMAL是以字符串形式存储的，所以会占用M个字节。











